<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ykk</title>
  
  <subtitle>Carpe diem</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ykksmile.top/"/>
  <updated>2018-06-26T13:11:49.487Z</updated>
  <id>https://ykksmile.top/</id>
  
  <author>
    <name>Ykk</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据库和操作系统笔试题总结（针对19校招</title>
    <link href="https://ykksmile.top/posts/23140/"/>
    <id>https://ykksmile.top/posts/23140/</id>
    <published>2018-06-26T11:38:17.000Z</published>
    <updated>2018-06-26T13:11:49.487Z</updated>
    
    <content type="html"><![CDATA[<p>总结19年校招遇到的数据库和操作系统笔试面试题，分门别类，放好备用。</p><a id="more"></a><hr><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="题目总结"><a href="#题目总结" class="headerlink" title="题目总结"></a>题目总结</h3><ol><li><p>数据库中存在学生表S、课程表C和学生选课表SC三个表，它们的结构如下：S(S#，SN，SEX，AGE，DEPT)C(C#，CN)SC(S#，C#，GRADE)其中：S#为学号，SN为姓名，SEX为性别，AGE为年龄，DEPT为系别，C#为课程号，CN为课程名，GRADE为成绩。请检索选修课程号为C2的学生中成绩最高的学号。( )</p><p> SELECT S# FORM SC WHERE C#=“C2” AND GRADE＞＝ALL (SELECT GRADE FORM SC WHERE C#=“C</p></li><li><p>数据库保护主要包括<strong>__</strong>、<strong>__</strong>、<strong>__</strong>和<strong>__</strong>。</p></li></ol><p>数据的安全性、完整性、并发控制、数据库恢复等 </p><ol start="3"><li>数据库中事务的四大特性（ACID）</li></ol><p>原子性 一致性 隔离性 持久性</p><hr><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p><strong>死锁产生的必要条件</strong>：</p><ul><li><p>互斥条件：进程要求对所分配的资源进行排他性控制，即在一段时间内某资源仅为一个进程所占用。此时若有其他进程请求该资源，则请求进程只能等待。</p></li><li><p>不剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放。</p></li><li><p>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</p></li><li><p>循环等待条件：存在一种进程资源的循环等待链，连中每一个进程已获得的资源同时被链中下一个进程所请求。</p></li></ul><p><strong>死锁避免</strong>：</p><ol><li>预防死锁(摒弃除1以外的条件)</li><li>避免死锁(银行家算法)</li><li>检测死锁(资源分配图)</li><li>解除死锁<ul><li>剥夺资源</li><li>撤销进程</li></ul></li></ol><h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><p>引入线程是为了减少程序在并发执行时所付出的时空开销。</p><p>定义：</p><p>一、进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是系统进行资源分配和调度的一个独立单位。<br>二、线程是进程的一个实体，是CPU调度和分派的基本单位，他是比进程更小的能独立运行的基本单位，线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），一个线程可以创建和撤销另一个线程；</p><p>进程和线程的关系：</p><p>（1）一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。<br>（2）资源分配给进程，同一进程的所有线程共享该进程的所有资源。<br>（3）线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。<br>（4）处理机分给线程，即真正在处理机上运行的是线程。<br>（5）线程是指进程内的一个执行单元，也是进程内的可调度实体。<br>线程与进程的区别：<br>（1）调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位。<br>（2）并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可以并发执行。<br>（3）拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。<br>（4）系统开销：在创建或撤销进程的时候，由于系统都要为之分配和回收资源，导致系统的明显大于创建或撤销线程时的开销。但进程有独立的地址空间，进程崩溃后，在保护模式下不会对其他的进程产生影响，而线程只是一个进程中的不同的执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但是在进程切换时，耗费的资源较大，效率要差些。</p><p>线程的划分尺度小于进程，使得多线程程序的并发性高。</p><p>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大的提高了程序运行效率。</p><p>线程在执行过程中，每个独立的线程有一个程序运行的入口，顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，有应用程序提供多个线程执行控制。</p><p>从逻辑角度看，多线程的意义子啊与一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</p><p><img src="https://blog-1252404748.cos.ap-chengdu.myqcloud.com/images/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.png" alt="进程线程"></p><hr><p>### </p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结19年校招遇到的数据库和操作系统笔试面试题，分门别类，放好备用。&lt;/p&gt;
    
    </summary>
    
      <category term="就业" scheme="https://ykksmile.top/categories/%E5%B0%B1%E4%B8%9A/"/>
    
      <category term="DataBase" scheme="https://ykksmile.top/categories/%E5%B0%B1%E4%B8%9A/DataBase/"/>
    
    
      <category term="DataBase" scheme="https://ykksmile.top/tags/DataBase/"/>
    
  </entry>
  
  <entry>
    <title>leetcode中Hashtable思路总结</title>
    <link href="https://ykksmile.top/posts/5454/"/>
    <id>https://ykksmile.top/posts/5454/</id>
    <published>2018-06-26T11:18:49.000Z</published>
    <updated>2018-06-26T11:56:50.128Z</updated>
    
    <content type="html"><![CDATA[<p>暂时没什么前言。</p><a id="more"></a><hr><h3 id="Happy-Number"><a href="#Happy-Number" class="headerlink" title="Happy Number"></a>Happy Number</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time:  O(k), where k is the steps to be happy number</span></span><br><span class="line"><span class="comment"># Space: O(k)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Write an algorithm to determine if a number is "happy".</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># A happy number is a number defined by the following process: </span></span><br><span class="line"><span class="comment"># Starting with any positive integer, replace the number by the sum </span></span><br><span class="line"><span class="comment"># of the squares of its digits, and repeat the process until </span></span><br><span class="line"><span class="comment"># the number equals 1 (where it will stay), or it loops endlessly </span></span><br><span class="line"><span class="comment"># in a cycle which does not include 1. Those numbers for which </span></span><br><span class="line"><span class="comment"># this process ends in 1 are happy numbers.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Example: 19 is a happy number</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 1^2 + 9^2 = 82</span></span><br><span class="line"><span class="comment"># 8^2 + 2^2 = 68</span></span><br><span class="line"><span class="comment"># 6^2 + 8^2 = 100</span></span><br><span class="line"><span class="comment"># 1^2 + 0^2 + 0^2 = 1</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param &#123;integer&#125; n</span></span><br><span class="line">    <span class="comment"># @return &#123;boolean&#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isHappy</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        lookup = &#123;&#125;</span><br><span class="line">        <span class="keyword">while</span> n != <span class="number">1</span> <span class="keyword">and</span> n <span class="keyword">not</span> <span class="keyword">in</span> lookup:</span><br><span class="line">            lookup[n] = <span class="keyword">True</span></span><br><span class="line">            n = self.nextNumber(n)</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span> <span class="comment"># True</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextNumber</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        new = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> str(n):</span><br><span class="line">            new += int(char)**<span class="number">2</span></span><br><span class="line"><span class="keyword">return</span> new</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span>(n!=<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">sum += Math.pow((n%<span class="number">10</span>),<span class="number">2</span>);</span><br><span class="line">n/=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(set.contains(sum))&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">set.add(sum);</span><br><span class="line">n=sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>### </p><hr><p>### </p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;暂时没什么前言。&lt;/p&gt;
    
    </summary>
    
      <category term="就业" scheme="https://ykksmile.top/categories/%E5%B0%B1%E4%B8%9A/"/>
    
      <category term="DataStructure" scheme="https://ykksmile.top/categories/%E5%B0%B1%E4%B8%9A/DataStructure/"/>
    
    
      <category term="Python" scheme="https://ykksmile.top/tags/Python/"/>
    
      <category term="Java" scheme="https://ykksmile.top/tags/Java/"/>
    
      <category term="Leetcode" scheme="https://ykksmile.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>数据结构笔试题总结（针对19校招</title>
    <link href="https://ykksmile.top/posts/44954/"/>
    <id>https://ykksmile.top/posts/44954/</id>
    <published>2018-06-26T10:40:39.000Z</published>
    <updated>2018-06-26T13:11:29.732Z</updated>
    
    <content type="html"><![CDATA[<p>总结19年校招遇到的数据结构笔试面试题，分门别类，放好备用。</p><a id="more"></a><hr><h3 id="赫夫曼树"><a href="#赫夫曼树" class="headerlink" title="赫夫曼树"></a>赫夫曼树</h3><p><a href="https://blog.csdn.net/wtfmonking/article/details/17150499" target="_blank" rel="noopener">哈夫曼树 C语言实现</a></p><p><strong>路径长度</strong>：<br>从树中一个结点到另一个结点之间的分支构成两个节点的路径，路径上的分支数目称作路径长度。</p><p><strong>WPL带权路径长度</strong>：<br>路径长度与节点上权的乘积。</p><p><code>WPL最短的树叫做赫夫曼树。</code></p><p><strong>赫夫曼编码</strong>：</p><p>字符集d1 d2 d3… 频率w1 w2 w3…</p><p>d为结点 w为权值构造赫夫曼树 左分支代表0 右分支代表1 根节点到叶子结点所经过的0和1的序列，即为赫夫曼编码。</p><p><strong>构造规则</strong>：</p><p>假设有n个权值，则构造出的哈夫曼树有n个叶子结点。 n个权值分别设为 w1、w2、…、wn，则哈夫曼树的构造规则为：</p><p>(1) 将w1、w2、…，wn看成是有n 棵树的森林(每棵树仅有一个结点)；</p><p>(2) 在森林中选出两个根结点的权值最小的树合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和；</p><p>(3)从森林中删除选取的两棵树，并将新树加入森林；</p><p>(4)重复(2)、(3)步，直到森林中只剩一棵树为止，该树即为所求得的哈夫曼树。</p><hr><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ol><li>设数组定义为a[60][70]，每个元素占2个存储单元，数组按照<code>列优先存储</code>，元素a[0][0]的地址为1024，那么元素a[32][58]的地址为（8048）</li></ol><p>a[60][70]有60行、70列，a[32][58]位于整个数组的33行、59列处，因为数组按照列优先存储，所以a[32][58]前面一共有</p><p>(59-1)<em>60+(33-1)=58</em>60+32=3512个元素，每个元素占2个存储单元，则一共占3512*2=7024个存储单元，</p><p>又因为a[32][58]的地址在2个存储单元的最前端，所以其地址为1024+7024=8048</p><hr><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><ol><li>设有序表中有1000个元素,则用二分查找查找元素X最多需要比较【 】次.</li></ol><p>比较10次。<br>1个元素的时候比较1次<br>2~3个元素比较2次<br>4~7个元素比较3次<br>8~15                4<br>16~31              5<br>32~63              6<br>64~127            7<br>128~255          8<br>256~511          9<br>512~1023       10<br>就是log2n取整后 +1</p><ol><li>下列排序算法中不能保证每趟排序至少能将一个元素放到其最终的位置上的是( )。</li></ol><p>A．快速排序<br>B．希尔排序<br>C．堆排序<br>D．起泡排序</p><p>B</p><ol><li>对大量数据排序(100万个),多种排序方法中,哪种最快、效率最高</li></ol><p>快速排序&gt;堆排序&gt;归并排序&gt;插入排序  数据达到10000000 堆排序优于快速排序</p><p><a href="https://blog.csdn.net/wqf363/article/details/1604458" target="_blank" rel="noopener">各种排序查询的算法效率比较</a></p><hr><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><ol><li>已知一棵二叉树，如果先序遍历的节点顺序是：ADCEFGHB，中序遍历是：CDFEGHAB，则后序遍历结果为：（） </li></ol><p>CFHGEDBA</p><p>先序遍历简单记为：根左右<br>中序遍历简单记为：左根右<br>后序遍历简单记为：左右根 </p><hr><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ol><li>若某表最常用的操作是在最后一个结点之后插入一个结点或删除最后一个结点。则采用（ ）存储方式最节省运算时间。</li></ol><p>双循环链表能够通过头结点的前驱就是尾结点，能够迅速找到尾结点，然后进行插入和删除操作</p><ol><li>已知一个线性表（38，25，74，63，52，48），假定采用散列函数h(key)=key%7计算散列地址，并散列存储在散列表A[0..6]中，若采用线性探测方法解决冲突，则在该散列表上进行等概率成功查找的平均查找长度为<strong>_</strong></li></ol><p>如果一个元素存入时，进行了N次散列，相应的查找次数也是N，所以38，25，63这三个元素的查找长度为1，74的查找长度为2，48的查找长度为3，52的查找长度为4。所以平均查找长度为：(1+1+1+2+3+4)/6=2。 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结19年校招遇到的数据结构笔试面试题，分门别类，放好备用。&lt;/p&gt;
    
    </summary>
    
      <category term="就业" scheme="https://ykksmile.top/categories/%E5%B0%B1%E4%B8%9A/"/>
    
      <category term="DataStructure" scheme="https://ykksmile.top/categories/%E5%B0%B1%E4%B8%9A/DataStructure/"/>
    
    
      <category term="DataStructure" scheme="https://ykksmile.top/tags/DataStructure/"/>
    
  </entry>
  
  <entry>
    <title>深信服复赛准备知识点</title>
    <link href="https://ykksmile.top/posts/42224/"/>
    <id>https://ykksmile.top/posts/42224/</id>
    <published>2018-06-21T12:51:00.000Z</published>
    <updated>2018-06-26T13:50:13.245Z</updated>
    
    <content type="html"><![CDATA[<p>准备深信服复赛。主要侧重安全部分（深信服是一家做安全的公司啊）。</p><a id="more"></a><hr><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="脆弱性"><a href="#脆弱性" class="headerlink" title="脆弱性"></a>脆弱性</h3><ul><li>缺乏数据源验证</li><li>缺乏机密性保障</li><li>缺乏完整性验证</li></ul><h3 id="安全风险"><a href="#安全风险" class="headerlink" title="安全风险"></a>安全风险</h3><p>由底向上：</p><p>设备破坏，侦听<br>MAC欺骗 泛洪<br>IP欺骗 ICMP攻击<br>TCP欺骗 TCP UDP拒绝服务<br>漏洞 缓冲区溢出</p><h3 id="网络的基本攻击模式"><a href="#网络的基本攻击模式" class="headerlink" title="网络的基本攻击模式"></a>网络的基本攻击模式</h3><ul><li>截获<ul><li>嗅探</li><li>监听</li></ul></li><li>篡改<ul><li>数据包篡改</li></ul></li><li>中断<ul><li>拒绝服务</li></ul></li><li>伪造<ul><li>欺骗</li></ul></li></ul><h3 id="信息安全的五要素"><a href="#信息安全的五要素" class="headerlink" title="信息安全的五要素"></a>信息安全的五要素</h3><ul><li>保密性</li><li>完整性</li><li>可用性</li><li>可控性</li><li>不可否认性</li></ul><p>安全实现：</p><ul><li>行为审计</li><li>授权访问</li><li>身份认证</li><li>数据加密</li></ul><hr><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h3 id="VPN概述"><a href="#VPN概述" class="headerlink" title="VPN概述"></a>VPN概述</h3><p><strong>VPN定义</strong>：</p><blockquote><p>依靠ISP或者NSP在公用网络基础设施上构建的专用的安全数据通信网络。</p></blockquote><p><strong>核心技术</strong>： <code>隧道技术</code></p><p><strong>VPN分类</strong>：</p><ul><li>Access VPN</li><li>LAN-LAN VPN</li></ul><p>IPSec GRE 位于网络层、SSL位于应用层、L2TP PPTP位于网络接口层。</p><p><strong>常用技术</strong>：</p><ol><li>隧道技术</li><li>加解密技术<ul><li>对称加密  IDEA <code>AES</code> RC <code>DES</code></li><li>非对称加密 ECCC <code>RSA</code> Rabin Elgamal</li></ul></li><li>身份认证技术<br> PKI体系，CA认证中心管理（Certificate Authority）。<br> 实例：HTTPS</li></ol><h3 id="IPSec"><a href="#IPSec" class="headerlink" title="IPSec"></a>IPSec</h3><p><strong>开放的协议族</strong>：<br><img src="https://blog-1252404748.cos.ap-chengdu.myqcloud.com/images/IPSec%E5%8D%8F%E8%AE%AE%E6%97%8F.png" alt="IPSec架构"></p><p><strong>IPSec工作模式</strong>：</p><ol><li>传输模式<br> 主机到主机之间，子啊包头后面插IPSec包头</li><li>隧道模式<br> 私网与私网之间，添加新的IP头和IPSec头</li></ol><p><strong>通信协议</strong>：</p><ol><li>AH  Authentication Header 协议号51<ul><li>无连接数据完整性</li><li>数据源认证</li><li>抗重放服务</li></ul></li><li>ESP 封装安全有效载荷 （DES AES）  协议号50<ul><li>AH的功能</li><li>数据保密</li><li>有限的数据流保护</li></ul></li></ol><p><strong>IKE协商</strong>：<br>为IPSec协商生成密钥，建立SA Security Association<br>两个阶段：</p><ul><li>IKE阶段1<ul><li>主模式<br>  SA交换、密钥交换、IP交换及验证，使用6条ISAKMP</li><li>野蛮模式 Aggressive<br>  三个交互包</li></ul></li><li>IKE阶段2<br>  协商IPSec参数</li></ul><p><strong>DPD解决VPN隧道黑洞</strong>： 超时计时器</p><p><strong>注意：</strong></p><ul><li>NAT下，只有ESP 隧道模式可用</li><li>NAT-T解决多个IPSec VPN （为ESP增加了UDP头）</li></ul><p><strong>深信服VPN优势</strong>：</p><ol><li>WebAgent （自动寻址</li><li>更细致的权限粒度</li><li>线路探测</li></ol><hr><h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><h3 id="上网行为安全"><a href="#上网行为安全" class="headerlink" title="上网行为安全"></a>上网行为安全</h3><p><strong>上网行为管理</strong>：</p><ol><li>用户认证</li><li>网页过滤</li><li>应用控制</li><li>流量管理</li><li>行为审计</li></ol><p><strong>互联网上网行为管控</strong>：</p><p>路由或网桥部署</p><ol><li>URL过滤+应用封堵</li><li>动态流控+P2P智能流控</li><li>基于网站等进行审计</li></ol><p><strong>一体化网关</strong></p><p><strong>无线wifi管控</strong>：</p><p>portal服务器上进行认证</p><p><strong>无线防共享上网</strong>：</p><p>网关或网桥模式部署在出口主干线路。</p><h3 id="上网行为组网方案"><a href="#上网行为组网方案" class="headerlink" title="上网行为组网方案"></a>上网行为组网方案</h3><p>问题思考:</p><ul><li>AC路由模式部署，不知道接口地址，如何登陆</li><li>如何恢复admin账号密码</li><li>恢复出厂设置</li></ul><h3 id="路由部署解决方案"><a href="#路由部署解决方案" class="headerlink" title="路由部署解决方案"></a>路由部署解决方案</h3><p>AC支持路由、网桥、旁路<br>SG支持路由、网桥、旁路、单臂</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;准备深信服复赛。主要侧重安全部分（深信服是一家做安全的公司啊）。&lt;/p&gt;
    
    </summary>
    
      <category term="Notes" scheme="https://ykksmile.top/categories/Notes/"/>
    
      <category term="比赛" scheme="https://ykksmile.top/categories/Notes/%E6%AF%94%E8%B5%9B/"/>
    
    
      <category term="ComputerNetwork" scheme="https://ykksmile.top/tags/ComputerNetwork/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络面试知识点总结</title>
    <link href="https://ykksmile.top/posts/54431/"/>
    <id>https://ykksmile.top/posts/54431/</id>
    <published>2018-06-11T09:16:56.000Z</published>
    <updated>2018-06-26T07:58:46.059Z</updated>
    
    <content type="html"><![CDATA[<p>一方面是在找工作之前对计算机网络/通信网络的回顾，另一方面准备深信服网络技术大赛。基于《计算机网络》第五版。</p><a id="more"></a><hr><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><h3 id="网络硬件"><a href="#网络硬件" class="headerlink" title="网络硬件"></a>网络硬件</h3><p>点到点 p2p<br>单播 unicasting<br>广播 broadcasting<br>组播 multicasting</p><h4 id="个域网-PAN"><a href="#个域网-PAN" class="headerlink" title="个域网 PAN"></a>个域网 PAN</h4><h4 id="局域网-LAN"><a href="#局域网-LAN" class="headerlink" title="局域网 LAN"></a>局域网 LAN</h4><p>接入点 AP access point<br>无线路由器 wireless router<br>基站 base station<br>WiFi IEEE 802.111<br>以太网 Ethernet 802.3</p><h4 id="域域网-MAN"><a href="#域域网-MAN" class="headerlink" title="域域网 MAN"></a>域域网 MAN</h4><h4 id="广域网-WAN"><a href="#广域网-WAN" class="headerlink" title="广域网 WAN"></a>广域网 WAN</h4><p>主机 host<br>子网 subnet<br>交换机 switch<br>路由器 router<br>ISP internet service provider<br>路由算法  转发算法</p><h4 id="互联网络"><a href="#互联网络" class="headerlink" title="互联网络"></a>互联网络</h4><h3 id="网络软件"><a href="#网络软件" class="headerlink" title="网络软件"></a>网络软件</h3><p>网络体系结构 network architecture<br>协议栈 protocol stack</p><h4 id="层次设计"><a href="#层次设计" class="headerlink" title="层次设计"></a>层次设计</h4><p>检错编码 error detection<br>纠错编码 error correction<br>路由 routing<br>寻址 addressing<br>命名 naming<br>统计复用 statistical multiplexing<br>拥塞 congestion<br>服务质量 qos queality of service</p><h4 id="面向连接和无连接"><a href="#面向连接和无连接" class="headerlink" title="面向连接和无连接"></a>面向连接和无连接</h4><h4 id="服务原语"><a href="#服务原语" class="headerlink" title="服务原语"></a>服务原语</h4><h4 id="服务与协议"><a href="#服务与协议" class="headerlink" title="服务与协议"></a>服务与协议</h4><h3 id="参考模型"><a href="#参考模型" class="headerlink" title="参考模型"></a>参考模型</h3><h4 id="OSI"><a href="#OSI" class="headerlink" title="OSI"></a>OSI</h4><ul><li>物理层 physical layer</li><li>数据链路层 data link layer</li><li>网络层 network layer</li><li>传输层 transport layer</li><li>会话层 session layer</li><li>表示层 presentation layer</li><li>应用层 application layer</li></ul><h4 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h4><ul><li>链路层</li><li>互联网层</li><li>传输层</li><li>应用层</li></ul><p>最终模型 </p><ul><li>物理层</li><li>数据链路层</li><li>网络层</li><li>传输层</li><li>应用层</li></ul><p>OSI 7层   TCP/IP 4层</p><h3 id="网络实例"><a href="#网络实例" class="headerlink" title="网络实例"></a>网络实例</h3><h4 id="因特网"><a href="#因特网" class="headerlink" title="因特网"></a>因特网</h4><ul><li>ARPANET</li><li>NSFNET</li></ul><p>Internet体系结构</p><p>连接到ISP：DSL Digital Subscriber Line</p><h4 id="3G"><a href="#3G" class="headerlink" title="3G"></a>3G</h4><p>宽带码分多址 WCDMA wideband code division multiple access<br>无线网络控制器 RNC radio network controller<br>核心网 core network<br>LTE long term evolution</p><h4 id="802-11"><a href="#802-11" class="headerlink" title="802.11"></a>802.11</h4><p>无线局域网</p><p>正交频分复用 OFDM orthogonal frequency division multiplexing<br>载波侦听多路访问 CSMA carrier sense multiple access</p><h4 id="RFID-传感器"><a href="#RFID-传感器" class="headerlink" title="RFID 传感器"></a>RFID 传感器</h4><h3 id="网络标准化"><a href="#网络标准化" class="headerlink" title="网络标准化"></a>网络标准化</h3><p>ITU international telecommunication union<br>ISO international standards organization</p><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><h3 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h3><h4 id="傅里叶分析和带宽"><a href="#傅里叶分析和带宽" class="headerlink" title="傅里叶分析和带宽"></a>傅里叶分析和带宽</h4><p>带宽 bandwidth<br>基带 baseband</p><h4 id="信道最大传输速率"><a href="#信道最大传输速率" class="headerlink" title="信道最大传输速率"></a>信道最大传输速率</h4><p>尼奎斯特定理<br>香农公式 最大比特率 = Blog2（1+S/N） B带宽 S/N 信噪比</p><h4 id="传输介质"><a href="#传输介质" class="headerlink" title="传输介质"></a>传输介质</h4><ul><li>双绞线 twisted pair</li><li>同轴电缆 coaxial cable</li><li>fiber</li></ul><h3 id="无线传输"><a href="#无线传输" class="headerlink" title="无线传输"></a>无线传输</h3><p>宽频技术：</p><ul><li>跳频扩频</li><li>直接序列扩频</li><li>超宽带通信 UWB</li></ul><h3 id="无线电-微波-红外-光通信-卫星"><a href="#无线电-微波-红外-光通信-卫星" class="headerlink" title="无线电 微波 红外 光通信 卫星"></a>无线电 微波 红外 光通信 卫星</h3><h3 id="数字调制与多路复用"><a href="#数字调制与多路复用" class="headerlink" title="数字调制与多路复用"></a>数字调制与多路复用</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一方面是在找工作之前对计算机网络/通信网络的回顾，另一方面准备深信服网络技术大赛。基于《计算机网络》第五版。&lt;/p&gt;
    
    </summary>
    
      <category term="Notes" scheme="https://ykksmile.top/categories/Notes/"/>
    
      <category term="就业" scheme="https://ykksmile.top/categories/Notes/%E5%B0%B1%E4%B8%9A/"/>
    
    
      <category term="ComputerNetwork" scheme="https://ykksmile.top/tags/ComputerNetwork/"/>
    
  </entry>
  
  <entry>
    <title>记一次参加dorahacks黑客马拉松的经历</title>
    <link href="https://ykksmile.top/posts/8806/"/>
    <id>https://ykksmile.top/posts/8806/</id>
    <published>2018-06-07T07:05:05.000Z</published>
    <updated>2018-06-12T07:07:39.012Z</updated>
    
    <content type="html"><![CDATA[<p>在6月2号，参加了dorahacks的黑客马拉松活动，即连续24小时编程比赛，打造一款产品。整体来说比赛一般，参与人数很少，并且小团体严重，后期感觉有互相换票的嫌疑，不过对于我自己来说，临时学习了区块链的知识，并与师弟一起，利用24小时，从零开发了一款基于区块链的APP（我负责后台，师弟负责前台）。</p><a id="more"></a><hr><h2 id="仓库地址"><a href="#仓库地址" class="headerlink" title="仓库地址"></a>仓库地址</h2><p><a href="https://github.com/cloisonne/blockchain" target="_blank" rel="noopener">基于区块链的记忆app的服务端</a><br><a href="https://github.com/cloisonne/Drifting" target="_blank" rel="noopener">基于区块链的心情漂流APP </a></p><hr><h2 id="针对blockchain做的改进"><a href="#针对blockchain做的改进" class="headerlink" title="针对blockchain做的改进"></a>针对blockchain做的改进</h2><h3 id="增加block属性"><a href="#增加block属性" class="headerlink" title="增加block属性"></a>增加block属性</h3><p>改进了block属性，以与记忆app（一款基于区块链的心情分享、漂流瓶社交应用）配合。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new_block</span><span class="params">(self, proof: int, my_message: str, previous_hash: Optional[str])</span> -&gt; Dict[str, Any]:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    生成新块</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :参数proof: 工作量证明算法给出的证明</span></span><br><span class="line"><span class="string">    :参数previous_hash: 上一个块的哈希值</span></span><br><span class="line"><span class="string">    :return: 一个新块</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    block = &#123;</span><br><span class="line">        <span class="string">'index'</span>: len(self.chain) + <span class="number">1</span>,</span><br><span class="line">        <span class="string">'my_message'</span>: my_message,</span><br><span class="line">        <span class="string">'timestamp'</span>: time(),</span><br><span class="line">        <span class="string">'transactions'</span>: self.current_transactions,</span><br><span class="line">        <span class="string">'proof'</span>: proof,</span><br><span class="line">        <span class="string">'previous_hash'</span>: previous_hash <span class="keyword">or</span> self.hash(self.chain[<span class="number">-1</span>]),</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="加入web端，与flask交互"><a href="#加入web端，与flask交互" class="headerlink" title="加入web端，与flask交互"></a>加入web端，与flask交互</h3><p>php实现 需要搭建apache+php环境。</p><h3 id="修改了挖矿等方法的method"><a href="#修改了挖矿等方法的method" class="headerlink" title="修改了挖矿等方法的method"></a>修改了挖矿等方法的method</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route('/mine', methods=['GET','POST'])</span></span><br></pre></td></tr></table></figure><h3 id="post-test"><a href="#post-test" class="headerlink" title="post_test"></a>post_test</h3><p>用于模拟post，发送挖矿请求。</p><hr><h2 id="PHP界面的实现"><a href="#PHP界面的实现" class="headerlink" title="PHP界面的实现"></a>PHP界面的实现</h2><p>效果如图：</p><p><img src="https://blog-1252404748.cos.ap-chengdu.myqcloud.com/images/php-blockchain.png" alt="区块链前端"></p><p>基于folk的php代码，根据flask后台改造了区块链前端。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;div align=<span class="string">"center"</span>&gt;</span><br><span class="line">&lt;form class="form-inline" action="index.php?port=&lt;?php echo $_REQUEST["port"]?&gt;&amp;mine=1" method="POST"&gt;</span><br><span class="line">  &lt;div class="form-group"&gt;</span><br><span class="line">&lt;label &gt;输入message：&lt;/label&gt;</span><br><span class="line">&lt;input type="text" class="form-control" id="my_message" name="my_message"&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;button type="submit" class="btn btn-primary"&gt;发送消息&lt;/button&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在6月2号，参加了dorahacks的黑客马拉松活动，即连续24小时编程比赛，打造一款产品。整体来说比赛一般，参与人数很少，并且小团体严重，后期感觉有互相换票的嫌疑，不过对于我自己来说，临时学习了区块链的知识，并与师弟一起，利用24小时，从零开发了一款基于区块链的APP（我负责后台，师弟负责前台）。&lt;/p&gt;
    
    </summary>
    
      <category term="Notes" scheme="https://ykksmile.top/categories/Notes/"/>
    
      <category term="比赛" scheme="https://ykksmile.top/categories/Notes/%E6%AF%94%E8%B5%9B/"/>
    
    
      <category term="区块链" scheme="https://ykksmile.top/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="PHP" scheme="https://ykksmile.top/tags/PHP/"/>
    
      <category term="安卓" scheme="https://ykksmile.top/tags/%E5%AE%89%E5%8D%93/"/>
    
  </entry>
  
  <entry>
    <title>车牌识别工作时间轴</title>
    <link href="https://ykksmile.top/posts/19204/"/>
    <id>https://ykksmile.top/posts/19204/</id>
    <published>2018-06-05T11:46:23.000Z</published>
    <updated>2018-06-22T14:05:48.400Z</updated>
    
    <content type="html"><![CDATA[<p>最近放弃了带遮挡的人脸识别，投身车牌识别的大业，这里的车牌识别是基于国内的、多种类的、恶劣条件下的，可以成为Real or Wild的plate recognition，将时间线和所做工作总结如下，主要同步自实验室的私有gitlab。</p><a id="more"></a><hr><h2 id="说下gitlab"><a href="#说下gitlab" class="headerlink" title="说下gitlab"></a>说下gitlab</h2><p>恰巧guyhub被微软收购了，未来可能会退出CN版的guyhub，当然如果是这样，外网guyhub应该是访问不了了，而国内的服务一定是遵守社会主义核心价值观，像host这样的开源库可能就要被灭绝了。</p><p>我们实验室内部代码交流和项目协作主要使用gitlab，一方面代码不便于在github公开仓库上共享，另一方面放着服务器不搭个写代码的平台也说不过去。gitlab的功能一定是比github更强大更丰富的，目前使用的功能还是比较少，对于git比较熟，所以也算得心应手。</p><hr><h2 id="开源库HyperLPR"><a href="#开源库HyperLPR" class="headerlink" title="开源库HyperLPR"></a>开源库HyperLPR</h2><p><a href="https://github.com/zeusees/HyperLPR" target="_blank" rel="noopener">HyperLPR</a>是基于深度学习的高性能中文车牌识别开源库，这里做一些研究，目前发现的问题有：</p><ul><li>EasyPR的数据集准确率并不高，大概60%？远达不到宣称的90%</li><li>框架使用深度学习，训练网络时数据集应该不够多，效果差强人意</li></ul><p>目前发现的优点有：</p><ul><li>端到端的神经网络训练模型进行车牌字符识别</li><li>代码比较轻量</li></ul><h3 id="工作流程分析"><a href="#工作流程分析" class="headerlink" title="工作流程分析"></a>工作流程分析</h3><p>对HyperLPR一个完整的车牌识别工作流程进行分析：</p><ol><li>batch.py  批量处理工具 批量读取文件调用pipline</li><li>pipline调用SimpleRecognizePlate函数（SimpleRecognizePlateByE2E ？）</li><li>detectPlateRough 传入灰度图 参数如下<ul><li>resize_h </li><li>en_scale</li><li>top_bottom_padding_rate</li></ul></li><li>调用模型’./model/cascade.xml’ 使用opencv中CascadeClassifier的detectMultiScale多尺度检测</li><li>车牌粗定位完成 进行SimplePredict 使用”./model/plate_type.h5”模型确定车牌类别（神经网络）</li><li>如果车型判断成功 对车牌进行bitwise_not二值化反色处理</li><li>调用finemapping中的精定位算法findContoursAndDrawBoundingBox</li><li>调用finemapping中的”./model/model12.h5”左右边界回归  进行垂直精定位算法finemappingVertical</li><li>调用e2e 使用模型”./model/ocr_plate_all_w_rnn_2.h5” 端到端字符识别  只输出不使用？</li><li>校正完成 使用segmentation中的slidingWindowsEval 进行文字分割和识别</li><li>置信度判断和输出</li></ol><p>注意事项：</p><ul><li>ocr_plate_all_gru.h5 作为序列模型效果更好，但是更慢  以上过程中未使用</li></ul><h3 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h3><p>完整修改了测试程序，并进行了正确率测试，大部分特殊车牌不支持，少数几种车牌识别率低于20%。</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plate_recogniton</span><span class="params">(real_path)</span>:</span></span><br><span class="line">    plate_real = real_path[:<span class="number">-4</span>].split(<span class="string">'\\'</span>)[<span class="number">-1</span>][:<span class="number">8</span>]</span><br><span class="line">    plate_real_list.append(plate_real)</span><br><span class="line">    print(<span class="string">'plate_real:'</span> + str(plate_real))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> real_path.endswith(<span class="string">".jpg"</span>) <span class="keyword">or</span> real_path.endswith(<span class="string">".png"</span>) <span class="keyword">or</span> real_path.endswith(<span class="string">".JPG"</span>):</span><br><span class="line">        image =  cv_imread(real_path)</span><br><span class="line">        <span class="comment"># print(type(image))</span></span><br><span class="line">        <span class="comment"># image,res  = model.SimpleRecognizePlateByE2E(image)</span></span><br><span class="line">        res = model.SimpleRecognizePlateByE2E(image)</span><br><span class="line">        max_res = [<span class="string">'null'</span>,<span class="number">0</span>,[<span class="number">862.01999999999998</span>, <span class="number">924.0</span>, <span class="number">178.03504678726196</span>, <span class="number">52.0</span>]]</span><br><span class="line">        res.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>],reverse=<span class="keyword">True</span>)</span><br><span class="line">        <span class="keyword">if</span> len(res) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">elif</span> len(res) &gt;= <span class="number">1</span>:</span><br><span class="line">            max_res = res[<span class="number">0</span>]</span><br><span class="line">        print(res)</span><br><span class="line">        plate_predict = max_res[<span class="number">0</span>]</span><br><span class="line">        print(<span class="string">'plate_predict:'</span> + plate_predict)</span><br><span class="line">        plate_predict_list.append(plate_predict)</span><br></pre></td></tr></table></figure><h3 id="模型的训练程序"><a href="#模型的训练程序" class="headerlink" title="模型的训练程序"></a>模型的训练程序</h3><p>使用<a href="https://github.com/armaab/hyperlpr-train" target="_blank" rel="noopener">Hyperlpr端到端车牌识别训练脚本</a></p><p>一个encoding问题：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.labels = []</span><br><span class="line">    <span class="keyword">with</span> open(self._label_file,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:   <span class="comment"># 强制utf-8</span></span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">            filename, label = parseLine(line)</span><br><span class="line">            self.filenames.append(filename)</span><br><span class="line">            self.labels.append(label)</span><br><span class="line">            self._num_examples += <span class="number">1</span></span><br><span class="line">    self.labels = np.float32(self.labels)</span><br></pre></td></tr></table></figure><p>代码跑出来loss到30%，在titan上大约30秒一个epoch</p><p>需要改进的：</p><ul><li>输出acc</li><li>输出网络模型</li></ul><h3 id="框架的改进思路"><a href="#框架的改进思路" class="headerlink" title="框架的改进思路"></a>框架的改进思路</h3><hr><p>## </p><p>### </p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近放弃了带遮挡的人脸识别，投身车牌识别的大业，这里的车牌识别是基于国内的、多种类的、恶劣条件下的，可以成为Real or Wild的plate recognition，将时间线和所做工作总结如下，主要同步自实验室的私有gitlab。&lt;/p&gt;
    
    </summary>
    
      <category term="Notes" scheme="https://ykksmile.top/categories/Notes/"/>
    
      <category term="比赛" scheme="https://ykksmile.top/categories/Notes/%E6%AF%94%E8%B5%9B/"/>
    
    
      <category term="Python" scheme="https://ykksmile.top/tags/Python/"/>
    
      <category term="MachineLearning" scheme="https://ykksmile.top/tags/MachineLearning/"/>
    
      <category term="DeepLearning" scheme="https://ykksmile.top/tags/DeepLearning/"/>
    
      <category term="PlateRecogniton" scheme="https://ykksmile.top/tags/PlateRecogniton/"/>
    
  </entry>
  
  <entry>
    <title>2018华为网赛云主机操作合集</title>
    <link href="https://ykksmile.top/posts/14112/"/>
    <id>https://ykksmile.top/posts/14112/</id>
    <published>2018-05-18T11:17:36.000Z</published>
    <updated>2018-06-05T11:45:57.289Z</updated>
    
    <content type="html"><![CDATA[<p>在华为2018网络技术大赛中拿到了全国亚军，3个小时的配置任务（包括华为manageone平台、fuisoninsight大数据平台、云主机操作），除了最后hue上的数据库操作比较费时，总共花了1个小时多一点就配完了，还是不错的成绩。这一篇是赛前整理的一些配置的linux命令。</p><a id="more"></a><hr><p>华为使用的云主机平台为SUSE Linux Enterprise servers，这里记一些网络决赛常用命令。</p><h2 id="文档分工"><a href="#文档分工" class="headerlink" title="文档分工"></a>文档分工</h2><p>肖 : FusionInsight HD V100R002C70SPC200 业务操作指南 02</p><p>zookeeper   yarn  mapreduce  hive  HDFS</p><p>董 ： ManageOne ServiceCenter 3.0.8 高危操作一览表 01</p><p>郭 ： ManageOne ServiceCenter 3.0.8 告警处理 01</p><p>需要分出去的： </p><p>FusionInsight HD V100R002C70SPC200 产品描述 02  企业级增强特性</p><h2 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h2><p><a href="http://man.linuxde.net/" target="_blank" rel="noopener">Linux命令大全</a></p><h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><p><a href="https://www.linuxidc.com/Linux/2016-10/136251.htm" target="_blank" rel="noopener">用户和用户组以及 Linux 权限管理</a></p><h4 id="etc-passwd-中的字段"><a href="#etc-passwd-中的字段" class="headerlink" title="/etc/passwd 中的字段"></a>/etc/passwd 中的字段</h4><ul><li>ACCOUNT：用户名</li><li>PASSWORD：密码占位符</li><li>UID：用户ID</li><li>GID：用户组ID</li><li>COMMAND：注释信息</li><li>HOME DIR：用户家目录</li><li>SHELL：用户的默认 shell</li></ul><h4 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h4><ul><li>useradd -u UID：指定 UID，这个 UID 必须是大于等于500，并没有其他用户占用的 </li><li>UID useradd -g  GID/GROUPNAME：指定默认组，可以是 GID 或者 GROUPNAME，同样也必须真实存在</li><li>useradd -G  GROUPS：指定额外组 </li><li>useradd -c COMMENT：指定用户的注释信息 </li><li>useradd -d PATH：指定用户的家目录</li><li>useradd -s SHELL：指定用户的默认 shell，最好是在 /etc/shells 中存在的路径 </li><li>useradd -s /sbin/nologin：该用户不能登录，还记得我们上面说到的系统用户不能登录吧？我们可以看到系统用户的 shell 字段也是</li><li>/sbin/nologin echo $SHELL ：查看当前用户的 shell 类型 useradd -M</li><li>USERNAME：创建用户但不创建家目录 useradd -mk USERNAME：创建用户的同时创建家目录，并复制 /etc/skel中的内容到家目录中。关于 /etc/skel 目录会在下一篇 Linux 权限管理中再次讲解。</li><li>如果用户没有家目录，那么不能切换到该用户</li></ul><h4 id="修改用户信息"><a href="#修改用户信息" class="headerlink" title="修改用户信息"></a>修改用户信息</h4><ul><li>usermod -G GROUPS USERNAME：改变用户的附加组，会完全替换原有的附加组 usermod -G -a GROUPS </li><li>USERNAME：在原有附加组的基础上追加附加组 usermod -d PATH      </li><li>USERNAME：修改家目录。修改后原先家目录中的文件不能访问了，因为在当前的家目录中并不存在这些文件。 usermod -l      </li><li>NEWNAME USERNAME：改变用户名 usermod -e USERNAME：指定该用户的过期时间 </li><li>usermod -L     USERNAME：锁定用户</li><li>usermod -U USERNAME：解锁用户</li></ul><h4 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h4><ul><li>id 显示用户属性</li><li>finger 检索用户信息</li><li>userdel 删除  -r删除家目录</li><li>groupadd -g GID GROUPNAME  groupdel   groupmod  gpasswd 组密码</li></ul><h3 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h3><h4 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h4><p> linux文件的用户权限的分析图</p><p>例：rwx　rw-　r–</p><p>r=读取属性　　//值＝4</p><p>w=写入属性　　//值＝2</p><p>x=执行属性　　//值＝1</p><pre><code>chmod u+x,g+w f01　　//为文件f01设置自己可以执行，组员可以写入的权限chmod u=rwx,g=rw,o=r f01chmod 764 f01chmod a+x f01　　//对文件f01的u,g,o都设置可执行属性</code></pre><h4 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h4><p>将目录/usr/meng及其下面的所有文件、子目录的文件主改成 liu：</p><pre><code>chown -R liu /usr/meng</code></pre><h3 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h3><h4 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h4><pre><code>ifconfigifconfig eth0 upifconfig eth0 down[root@localhost ~]# ifconfig eth0 192.168.2.10[root@localhost ~]# ifconfig eth0 192.168.2.10 netmask 255.255.255.0[root@localhost ~]# ifconfig eth0 192.168.2.10 netmask 255.255.255.0 broadcast 192.168.2.255</code></pre><h3 id="SLA指标"><a href="#SLA指标" class="headerlink" title="SLA指标"></a>SLA指标</h3><ul><li>df 查看分区</li><li>route -n 路由</li><li>cat /etc/recolv.conf</li><li>ifconfig</li></ul><h3 id="分区管理"><a href="#分区管理" class="headerlink" title="分区管理"></a>分区管理</h3><p><a href="https://blog.csdn.net/beyondlpf/article/details/10147037" target="_blank" rel="noopener">linux 分区 物理卷 逻辑卷</a></p><h4 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h4><pre><code>fdisk -l83 是代表EXT2和EXT382 是代表SWAP分区fdisk   /dev/sda D删除一个分区N创建一个分区Q 不保存退出T改变分区IDW保存退出 partprobemkfs    -t   ext3   /dev/sda7 mkdir   /mnt/backupmount   -t   ext3   /dev/sda7    /mnt/backup mkfs.ext3   /dev/sdaxt  改变分区类型LVM  8el 查看分区类型编号</code></pre><h4 id="创建LVM"><a href="#创建LVM" class="headerlink" title="创建LVM"></a>创建LVM</h4><pre><code>pvcreate   /dev/sdax vgcreate     myvg        /dev/sda8lvcreate  -L  大小  卷组名  -n  逻辑卷名称mkfs.ext3   /dev/myvg/mylv1 mkdir   /mnt/mylv1 mount   -t   ext3   /dev/myvg/mylv1   /mnt/mylv1 lvdisplaylvcreate   -L  150M   myvg   -n   mylv2mkfs.ext3   /dev/myvg/mylv2mkdir   /mnt/mylv2mount   -t   ext3   /dev/myvg/mylv2   /mnt/mylv2 lvresize   -L   绝对大小   对象lvresize   -L   100M   /dev/myvg/mylv2 resize2fs   /dev/myvg/mylv2</code></pre><h2 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h2><h3 id="产品架构"><a href="#产品架构" class="headerlink" title="产品架构"></a>产品架构</h3><p><code>FusionInsight HD V100R002C70SPC200 产品描述 02</code></p><ul><li><p>DBservice<br>  一个具备高可靠性的传统关系型数据库，为Hive、 Hue、 Spark组件提供元数据存储服务。</p></li><li><p>HBase<br>  提供海量数据存储功能，是一种构建在HDFS之上的分布式、面向列的存储系统。</p></li><li><p>HDFS<br>  Hadoop分布式文件系统（Hadoop Distributed File System），提供高吞吐量的数据访问，适合大规模数据集方面的应用。</p></li><li><p>Hive<br>  建立在Hadoop基础上的开源的数据仓库，提供类似SQL的Hive Query Language语言操作结构化数据存储服务和基本的数据分析服务。</p></li><li><p>Hue<br>  提供了FusionInsight HD应用的图形化用户Web界面。 Hue支持展示多种组件，目前支持HDFS、YARN/MapReduce、 Hive和Solr。</p></li><li><p>KrbServer 及 LdapServer<br>  通过KrbServer为所有组件提供Kerberos认证功能，实现了可靠的认证机制。LdapServer支持轻量目录访问协议（Lightweight Directory Access Protocol，简称为LDAP），为Kerberos认证提供用户和用户组数据保存能力。</p></li><li><p>Mapreduce<br>  提供快速并行处理大量数据的能力，是一种分布式数据处理模式和执行环境。</p></li><li><p>Yarn<br>  资源管理系统，它是一个通用的资源模块，可以为各类应用程序进行资源管理和调度。</p></li><li><p>ZooKeeper<br>  提供分布式、高可用性的协调服务能力。帮助系统避免单点故障，从而建立可靠的应用程序。</p></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在华为2018网络技术大赛中拿到了全国亚军，3个小时的配置任务（包括华为manageone平台、fuisoninsight大数据平台、云主机操作），除了最后hue上的数据库操作比较费时，总共花了1个小时多一点就配完了，还是不错的成绩。这一篇是赛前整理的一些配置的linux命令。&lt;/p&gt;
    
    </summary>
    
      <category term="Notes" scheme="https://ykksmile.top/categories/Notes/"/>
    
      <category term="比赛" scheme="https://ykksmile.top/categories/Notes/%E6%AF%94%E8%B5%9B/"/>
    
    
      <category term="Linux" scheme="https://ykksmile.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>有遮挡的人脸识别论文阅读整理</title>
    <link href="https://ykksmile.top/posts/9363/"/>
    <id>https://ykksmile.top/posts/9363/</id>
    <published>2018-05-14T02:29:36.000Z</published>
    <updated>2018-06-05T11:46:02.036Z</updated>
    
    <content type="html"><![CDATA[<p>暂时决定先跑个RSC，后面需要改进时继续整理论文。</p><a id="more"></a><hr><h2 id="现有研究和背景"><a href="#现有研究和背景" class="headerlink" title="现有研究和背景"></a>现有研究和背景</h2><p>现有的用于解决部分遮挡的人脸识别的方法：</p><ol><li>基于 <code>KL</code>（Karhunen Loeve ,KL）扩展的方法：这类方法对原始训练数据进行预处理，然后通过KL变换求得主成分作为分类的特征，最后用稀疏表示分类 （Sparse Representation Classification，SRC）进行分类。<br>典型的方法包括：<ul><li><code>RSC</code>（Robust Sparse Coding）</li><li><code>LRMA</code>（Low Rank Matrix Approximation） </li><li><code>SDR-SLR</code>（Supervised Low Rank Dictionary Decomposition ,SDR-SLR）将训练数据分离成与身份有关信息、与身份无关信息以及噪声部分，能有效地提高有遮挡的人脸识别率。<br>以上方法强调了在训练数据中结构不协调的重要性，即 尽可能地从独立的不同类中学习到变换矩阵。</li></ul></li><li><del>基于模型的方法： 主要代表方法是基于 3D 模型的人脸识别，这类通过更多的摄像传感器获取人脸的三维模型来进行识别与认证，对于人脸的姿态、表情、 光照、 遮挡等变化都有非常稳健的性能。 Nese Alyuz提出了一种完全自动的三维 人脸识别系统，对遮挡的情况具有鲁棒性。它主要针对表面有遮挡的人脸识别和基于子空间分析技术引起的数据丢失进行分类，利用未被遮挡的部分进行训练，遮挡部分被剔除。在分类阶段采取掩蔽策略，是一种利用不完备数据进行子空间分析的 技术，进一步来说就是用局部处理的方法来改善全局的质量。</del></li><li><del>基于相关的方法： Felix Juefei-Xu 在文章[12]中提出了在表情、遮挡、 姿态变 化下的 3D<br>人脸识别。文章[15]提出了一种新的几何框架，用螺旋弯曲的方法去对 比、匹配、<br>平均化他们的形状并表示面部的表面，去创建一个黎曼结构，用于分析 面部表面的形状。 A. M.<br>Ali[13]提出了一种在远距离框架下姿态不变的 3D 人脸识别 模型。能自动获取图形完成人脸识别。</del></li><li>基于<code>模板</code>的方法： JongJu 在文章[14]中提出了一种在遮挡下对面部特征检测<br>和追踪的方法，初始化阶段、检测人脸、估计面部的姿态，根据检测出来的人脸， 初始化与姿态有关的特征集合；<br>优化阶段将海森矩阵与轮廓梯度向量以及外观误 差联合起来更新参数集，进而获得面部的参数， 通过加入一个模板脸将特征检测延 伸到人脸追踪，<br>使得在重度遮挡的情况下依然能实现更为精确的面部特征识别。</li><li>基于<code>特征</code>的方法： 字符串匹配是一种非常有力的部分匹配技术，但是并不<br>适合正面的人脸识别，因为人脸包括连续和不连续的特征，需要利用全局序列来表 Weiping<br>Chen[16]提出了一种使用全局字符串匹配的人脸识别方法，它利用非常<br>紧凑的语法描述字符串去表示人脸，可以在两张不连续的字符串脸间完成匹配。因 为人脸字符串的相继顺序和方向都不变，<br>这个潜在的性质使得算法在识别过程中 能够自动利用每一块没有被遮挡的区域，而不用去管形状是什么样。 这种方法在训<br>练样本数量很少时同样有效。实验验证上述方法不仅在部分遮挡的人脸识别中有<br>显著的性能，而且有能力将素描的人脸和相片里面的人脸进行匹配。另外一种是<br>Lingfeng[17]提出来的流形正则化的局部稀疏表示方法（MRLSR）， 该方法认为在稀 疏表示条件下所有的编码向量都是组稀疏的。具有个体稀疏和局部相似两条性质。 利用这些性质能有效地提升有部分遮挡情况下的人脸识别率。</li><li>基于<code>神经网络</code>的方法： 随着近几年深度学习研究的深入，基于神经网络的人脸识别研究也获得了许多进步，其中香港中文大学的汤晓鸥团队提出的基于深度学习[18-20]的人脸识别，利用卷积神经网络学习特征，刷新了人脸识别率的新高 峰。 DeepID特征可以从卷积神经网络的最后一个隐藏层提出来，在学习基于卷积 神经网络的分类器时，沿着特征提取的层次结构减少神经元的个数，这个卷积神经网络的顶层神经元个数会逐渐减少，最后只保留几个与身份相关的神经元。 Y. Sun[19]针对人脸识别中很难有效提取到能降低类内变化并增加类间变化的特征这个问 题，提出了 <code>DeepID2</code> 特征。实验证明使用DeepID2 特征能更加有效地提升识别率。 在文章[20]中提出了一种更高性能的卷积神经网络，通过增加隐藏表示的维数并在前面的卷积层加入监督，使得 DeepID2+获得更好的识别率， 实验证明了 DeepID2+ 对于遮挡情况也十分稳健。</li></ol><h2 id="现有数据库："><a href="#现有数据库：" class="headerlink" title="现有数据库："></a>现有数据库：</h2><ol><li>AR 人脸图像数据库： 包含 126 个人的四千多张正面人脸图像，其中男性<br>70 个，女性 56 个。每个人有 26 张人脸图像，其中包含了光照变化、表情变化、<br>还有眼镜遮挡和围巾遮挡。该人脸数据库中的图像分别间隔了两周的时间采集：<br>session1 和 session2，每个时间段每个人采集了 13 张。</li><li>FERET 人脸图像数据库： 美国军方组织的 FERET 人脸识别算法测试[5]，<br>主要为了解决成像条件理想、用户配合、中小规模人脸数据库上的人脸识别问题。<br>该数据库包含有 14,051 张人脸图像， 每张人脸图像有姿态和光照的变化，并且主<br>要为白种人。</li><li>Yale 人脸数据库： 包含有 15 个人的 165 张 GIF 格式的灰度图片， 其中每<br>个人有 11 张人脸图像，包含了丰富的表情变化和光照变化， 比如：快乐、伤心、<br>惊讶、正常、 困倦、眨眼、 左偏光、 中心光、右偏光等。</li><li>Yale 人脸数据库 B： 在 576 个观察条件下（9 种不同姿态64 种光照条件）<br>采集到的 10 个自愿者的 5760 张人脸图像， 即每个自愿者在每一种观察条件下采<br>集到一张人脸图像。</li><li>PIE 人脸数据库： 由 68 个人的的 41368 张人脸图像组成，其中每个人的人<br>脸图像是在 13 种不同姿态、 43 种不同的光照、 4 种不同的表情条件下采集到的。</li><li>SCface 人脸数据库： 由 130 个人的 4060 张静态人脸图像构成， 人脸图像<br>是在室内用五架分辨率不一的摄像机采集的。 SCface 人脸数据库是开源的， 可以<br>很方便的获取。</li><li>LFW 人脸数据库： 该数据库由美国马萨诸塞大学阿姆斯特分校计算机视觉<br>实验室整理完成，主要研究非受限情形下的人脸识别问题，现在已成为学术界乃至<br>工业界评价识别性能的 benchmark。该数据库包含了 5749 个人的 13233 幅人脸图<br>像，这些人脸图像主要是从互联网上收集的，反映了真实场景下的人脸图像，比如<br>大的姿态变化、光照变化、表情变化、任意的遮挡等。</li></ol><h2 id="论文观点整理"><a href="#论文观点整理" class="headerlink" title="论文观点整理"></a>论文观点整理</h2><h3 id="有部分遮挡的人脸识别方法研究"><a href="#有部分遮挡的人脸识别方法研究" class="headerlink" title="有部分遮挡的人脸识别方法研究"></a>有部分遮挡的人脸识别方法研究</h3><p><strong>因为人脸这边不做了，集中精力搞车牌，暂时不更新了。</strong></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;暂时决定先跑个RSC，后面需要改进时继续整理论文。&lt;/p&gt;
    
    </summary>
    
      <category term="Notes" scheme="https://ykksmile.top/categories/Notes/"/>
    
      <category term="比赛" scheme="https://ykksmile.top/categories/Notes/%E6%AF%94%E8%B5%9B/"/>
    
    
      <category term="MachineLearning" scheme="https://ykksmile.top/tags/MachineLearning/"/>
    
      <category term="FaceRecognition" scheme="https://ykksmile.top/tags/FaceRecognition/"/>
    
  </entry>
  
  <entry>
    <title>机器学习路线和清单</title>
    <link href="https://ykksmile.top/posts/17158/"/>
    <id>https://ykksmile.top/posts/17158/</id>
    <published>2018-05-12T03:03:45.000Z</published>
    <updated>2018-06-05T11:44:35.455Z</updated>
    
    <content type="html"><![CDATA[<p>写给师妹的机器学习路线和清单。</p><a id="more"></a><hr><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>目前这是互联网领域最火的科目之一，一方面是高薪，另一方面是层出不穷的辅导班，未来很难说，不过这绝对是一个容易入门但很难做好做出成绩的方向。</p><p>想要找到一份不错的工作，需要更好的对算法底层的理解，需要刷一些相关的题目，需要有竞赛经验或者顶会论文才可以。</p><p>但是只要努力，总会得到自己想要的吧。</p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><h3 id="周志华的西瓜书《机器学习》"><a href="#周志华的西瓜书《机器学习》" class="headerlink" title="周志华的西瓜书《机器学习》"></a>周志华的西瓜书《机器学习》</h3><p>这本书是很多人推荐给新手的入门书，与此类似的还有吴恩达的机器学习课程，我觉得都很一般，特别是这本书，基本上对新手入门不太友好，但是对于有一定基础的确实可以缩短时间，可以省去很多选择的时间，把精力专注在一本书上，下面是一些推荐学习的tips：</p><ol><li>对于机器学习算法的统筹感官，推荐阅读：<br><a href="https://blog.csdn.net/u011001084/article/details/52523897" target="_blank" rel="noopener">机器学习常用 35 大算法盘点（附思维导图）</a></li><li>基于此，一些学习机器学习所需的前置条件就可以有所了解了，比如概率论、工程优化、基本的关联规则等等，这些内容我建议用到的直接增量学习。</li><li>开始西瓜书的学习，第一遍难点略过，注意把握统筹感受，这个阶段搞不明白损失函数到底是什么实在是很正常的事情，只需要知道一些专业术语，和这些算法是什么即可。</li></ol><h3 id="什么是我最推崇的增量学习？"><a href="#什么是我最推崇的增量学习？" class="headerlink" title="什么是我最推崇的增量学习？"></a>什么是我最推崇的增量学习？</h3><p>例如在logistic对数回归的学习中，需要对公式进行推导，这里用到了高等数学的基本概念；或者对于贝叶斯分类器，这里需要概率论与数理统计的基本概念。重点是，不会这些推导会影响你对算法的整体感知吗，不会的，所以可以选择性略过，节约了大量的时间。如果选择要死啃，此时遇到什么再去学习什么，翻到对应章节，切忌拿一本概率论苦读。</p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>实战主要是使用python，sklearn库，进行库函数的调取，这里前置条件又很多，如下：</p><ul><li>python语言，会写即可，不需要学习web开发、GUI等第三方模块</li><li>还是学python3，学会了python2也会了</li><li>python的第三方库，包括numpy pandas 还有画图使用的mayplotlib和seaborn等</li><li>IDE建议使用pycharm，对新手友好，实在是很反感各种新手教学上来就要摸linux配环境的行为，除了加大难度有屁用？</li><li>除了pycharm之外，熟悉ipython的交互形式，最好能够接触到jupyter notebook</li></ul><h3 id="学习方式："><a href="#学习方式：" class="headerlink" title="学习方式："></a>学习方式：</h3><ol><li>对于聪明人，直接看库函数API文档即可，我没有花时间学过python，直接上手写的，用到什么功能什么函数直接百度或者查python的文档即可<ul><li><a href="https://docs.python.org/3.6/" target="_blank" rel="noopener">python3.6 doc</a></li><li><a href="https://matplotlib.org/api/index.html" target="_blank" rel="noopener">matplotlib API</a></li><li><a href="http://scikit-learn.org/stable/documentation.html" target="_blank" rel="noopener">sklearn API</a><br>需要注意的是，在sklearn官网上实在有太多example，配合pycharm使用，可以很快的上手机器学习代码。</li></ul></li><li>对于不聪明的人，可以读一些书，去图书馆搜以下关键词，随便挑一本封面看着比较新的入门就可以了。<ul><li>机器学习实战</li><li>数据分析</li><li>python+数据</li></ul></li><li>推荐使用脑图学习，这也是我最新喜欢的方式，这里使用百度脑图，web打开即用，十分方便：<ul><li><a href="http://naotu.baidu.com/" target="_blank" rel="noopener">百度脑图</a></li></ul></li></ol><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>在这个阶段，通过代码上手，我们已经知道了一个基本的机器学习程序流程了：</p><ul><li>数据预处理</li><li>特征分析</li><li>更复杂的数据处理</li><li>丢到机器学习库里</li><li>调整一些参数</li><li>fit一个模型，predict一个结果</li></ul><p>就是这么简单。</p><p>在这个阶段最重要的是搞清楚一些之前很模糊的概念，比如loss，推荐阅读：</p><p><a href="https://blog.csdn.net/u010976453/article/details/78488279" target="_blank" rel="noopener">机器学习中的损失函数 （着重比较：hinge loss vs softmax loss）</a></p><p>比如几个重点模型的推导，简单的知识对应关系如下：</p><ul><li>线性回归逻辑回归  —— 高等数学</li><li>贝叶斯分类 —— 概率论</li><li>神经网络 —— 最优化</li></ul><p>以神经网络为例，最需要搞明白的是梯度下降和反向传播这几个概念，我想如果走到这一步，神经网络的路线也是了然于胸了，从感知器到CNN到RNN到LSTM即可。</p><p>这里也可以参考我的另一篇文章：</p><p><a href="/posts/55073/">面试准备阅读列表</a></p><h2 id="应试"><a href="#应试" class="headerlink" title="应试"></a>应试</h2><p>学习的目的，不是搞科研，发paper，只是为了找工作而已，找工作就要应试，这里建议看七月在线的题目：</p><p><a href="https://www.julyedu.com/question/index" target="_blank" rel="noopener">七月在线题库</a></p><h2 id="比赛"><a href="#比赛" class="headerlink" title="比赛"></a>比赛</h2><p>此外，如果希望做一些比赛，应当从kaggle入手，从最简单的titanic开始即可，有很多人写的kernel（即一些入门教程和示例程序），这里需要有一定的英语水平，其实哪里都需要英语好，英语好了有些问题直接stackoverflow，直接google就好了，很简单。</p><p><a href="https://www.kaggle.com/" target="_blank" rel="noopener">kaggle地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写给师妹的机器学习路线和清单。&lt;/p&gt;
    
    </summary>
    
      <category term="Notes" scheme="https://ykksmile.top/categories/Notes/"/>
    
      <category term="机器学习" scheme="https://ykksmile.top/categories/Notes/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Python" scheme="https://ykksmile.top/tags/Python/"/>
    
      <category term="MachineLearning" scheme="https://ykksmile.top/tags/MachineLearning/"/>
    
  </entry>
  
  <entry>
    <title>华为2018网络大赛超纲内容整理</title>
    <link href="https://ykksmile.top/posts/27479/"/>
    <id>https://ykksmile.top/posts/27479/</id>
    <published>2018-04-20T05:28:46.000Z</published>
    <updated>2018-06-05T11:45:18.491Z</updated>
    
    <content type="html"><![CDATA[<p>2017年在该比赛中获得了西北赛区第二，在此记录一下2018年华为网络大赛可能会出现的超纲知识点，包括云计算、大数据、Docker、微服务等等。</p><a id="more"></a><hr><h2 id="学习视频笔记"><a href="#学习视频笔记" class="headerlink" title="学习视频笔记"></a>学习视频笔记</h2><p>这里是folk的github上2017年有人写的笔记，其中有一定出入，SDN/NFV的内容应该是被删除了。</p><div class="github-widget" data-repo="cloisonne/Huawei-2018-network"></div><h2 id="记录的超纲内容"><a href="#记录的超纲内容" class="headerlink" title="记录的超纲内容"></a>记录的超纲内容</h2><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>自动化内存管理(Automatic Memory Management,AMM) </p><ol><li><a href="https://www.cnblogs.com/dato/p/7049343.html" target="_blank" rel="noopener">浅谈 DML、DDL、DCL的区别</a> </li></ol><h4 id="DML、DDL、DCL的区别"><a href="#DML、DDL、DCL的区别" class="headerlink" title="DML、DDL、DCL的区别"></a>DML、DDL、DCL的区别</h4><ul><li>DML（data manipulation language）数据操纵语言</li><li>DDL（data definition language）数据库定义语言</li><li>DCL（Data Control Language）数据库控制语言</li></ul><h4 id="其他知识点"><a href="#其他知识点" class="headerlink" title="其他知识点"></a>其他知识点</h4><ul><li>RMAN对数据库恢复，数据库处于mount状态</li><li>编译SQL 访问共享池</li><li>查询表数据 需要处于open状态</li><li>AMM下，可以自动调整大小的包括 共享池、大型池</li></ul><h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><ol><li><a href="https://blog.csdn.net/silencezyn1208/article/details/72236562" target="_blank" rel="noopener">微服务架构浅谈(一)</a> </li><li><a href="https://blog.csdn.net/zeb_perfect/article/details/52536411" target="_blank" rel="noopener">微服务要素-十二要素（The Twelve Factors）</a> </li></ol><ul><li>微服务和单体式应用的区别</li><li>12-factor中的重点<ul><li>基准代码</li><li>依赖</li><li>等等</li></ul></li></ul><h3 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h3><ol><li><a href="http://www.360doc.com/content/16/0421/20/16915_552675362.shtml" target="_blank" rel="noopener">开源大数据处理工具汇总 </a> </li><li><a href="https://www.zhihu.com/question/53331259" target="_blank" rel="noopener">kafka解决了什么问题? </a> </li></ol><ul><li>cloudera的flume，分布式的日志系统</li><li>kafka 是一个分布式的、分区的、多复本的日志提交服务，是一个消息系统。</li><li>zookeeper  是一个分布式的、开放式的分布式应用程序协调服务</li><li>GFS是一个可扩展的分布式文件系统，用于大型的、分布式的、对大量数据进行访问的应用。</li><li>Chubby被设计成为一个需要访问中心化的分布式锁服务。</li><li>BigTable是Google设计的分布式数据存储系统,用来处理海量的数据的一种非关系型的数据库。</li></ul><ol><li><a href="https://blog.csdn.net/zonzereal/article/details/78095110" target="_blank" rel="noopener">hadoop的三大核心组件</a> </li></ol><ul><li>HDFS</li><li>YARN<br>  YARN可以调度的包括Spark Storm MapReduce</li><li>MapReduce</li></ul><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><ol><li><a href="https://blog.csdn.net/u013485792/article/details/76071252" target="_blank" rel="noopener">NAPT和NAT的工作原理及其区别</a> </li></ol><p>NAPT 即加端口号 :8888  NAT为IP映射</p><ul><li>虚拟交换机工作在第二层</li><li>在802.1q中,vlan配置的最大可能值为4094 ， 其中0 和 4095保留</li></ul><p><code>Trunk端口既能发送带标签的数据帧，也能发送不带标签的数据帧。</code></p><p>Access端口发往其他设备的报文，都是Untagged数据帧， 而Trunk端口仅在一种特定情况下才能发出untagged数据帧，其它情况发出的都是Tagged数据帧。Hybrid端口是交换机上既可以连接用户主机，又可以连接其他交换机的端口。</p><p>Hybrid端口既可以连接接入链路又可以连接干道链路。Hybrid端口允许多个VLAN的帧通过，并可以在出端口方向将某些VLAN帧的Tag剥掉。华 为设备默认的端口类型是Hybrid。</p><p>Trunk端口收发数据帧的规则如下：</p><ol><li>当接收到对端设备发送的不带Tag的数据帧时，会添加该端口的 PVID，如果PVID在允许通过的VLAN ID列表中，则接收该报文，否则丢 弃该报文。当接收到对端设备发送的带Tag的数据帧时，检查VLANID是 否在允许通过的VLANID列表中。如果VLANID在接口允许通过的VLANID 列表中，则接收该报文。否则丢弃该报文。</li><li>端口发送数据帧时，当VLAN ID与端口的PVID相同，且是该端口允许通 过的VLAN ID时(两个条件)，去掉Tag，发送该报文。<br>当VLANID与端口的PVID不同，且是该端口允许通过的VLANID时，保持原有Tag，发送该报文。</li></ol><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>停止httpd服务：</p><ul><li>killall httpd</li><li>/etc/init.d/httpd stop</li><li>service httpd stop</li></ul><p>注意，httpd是一个进程组，有子进程，kill不能停止。</p><ul><li>路由表中，有目的地址、下一跳、出接口</li></ul><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><ol><li><a href="https://blog.csdn.net/mengdonghui123456/article/details/52935486" target="_blank" rel="noopener">docker 三组件：镜像、容器、仓库</a> </li></ol><p>docker的资源控制：</p><ul><li>blkio 输入输出</li><li>cpu cpu</li><li>namespace 隔离</li><li>devices 控制设备访问</li><li>freezer 挂起或恢复</li><li>net-cls 标记网络数据包</li></ul><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><p>NAS和SAN的区别</p><ul><li>SAN 本身不自带文件系统，占用客户端资源提供文件系统功能；NAS 本身自 带文件系统 </li><li>SAN 存储通常使用 iSCSI、FC 等协议；NAS 通常使用 NFS、CIFS 等协议 </li><li>NAS 和 SAN 可以整合在同一台存储设备上，即可以实现一台存储产品既用于 SAN，又用于 NAS</li></ul><p>LVM逻辑卷扩展</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2017年在该比赛中获得了西北赛区第二，在此记录一下2018年华为网络大赛可能会出现的超纲知识点，包括云计算、大数据、Docker、微服务等等。&lt;/p&gt;
    
    </summary>
    
      <category term="Notes" scheme="https://ykksmile.top/categories/Notes/"/>
    
      <category term="比赛" scheme="https://ykksmile.top/categories/Notes/%E6%AF%94%E8%B5%9B/"/>
    
    
      <category term="大数据" scheme="https://ykksmile.top/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="云计算" scheme="https://ykksmile.top/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="Docker" scheme="https://ykksmile.top/tags/Docker/"/>
    
      <category term="微服务" scheme="https://ykksmile.top/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>华为2018软件精英挑战赛初赛记录</title>
    <link href="https://ykksmile.top/posts/59415/"/>
    <id>https://ykksmile.top/posts/59415/</id>
    <published>2018-04-16T12:58:36.000Z</published>
    <updated>2018-06-04T12:48:20.268Z</updated>
    
    <content type="html"><![CDATA[<p>2018华为软件精英挑战赛初赛的思路和代码总结。</p><a id="more"></a><hr><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="github地址"><a href="#github地址" class="headerlink" title="github地址"></a>github地址</h3><div class="github-widget" data-repo="cloisonne/huawei-2018-software"></div><h3 id="用到的网址"><a href="#用到的网址" class="headerlink" title="用到的网址"></a>用到的网址</h3><p><a href="https://blog.csdn.net/u013719780/article/details/77435158" target="_blank" rel="noopener">手把手教你实现线性回归模型</a></p><p><a href="https://blog.csdn.net/jiede1/article/details/78245597" target="_blank" rel="noopener">机器学习算法—随机森林实现（包括回归和分类）</a></p><p><a href="https://blog.csdn.net/ppp8300885/article/details/77934822" target="_blank" rel="noopener">新手向的时间序列预测解决方案-前Top2%</a></p><hr><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="stacking"><a href="#stacking" class="headerlink" title="stacking"></a>stacking</h3><p>主要采用模型堆叠，stacking的方式，stack了包括拉格朗日均值、随机森林回归、线性回归、指数平滑等算法，利用本地调试脚本，进行参数优化。</p><h3 id="序列预测的平滑处理"><a href="#序列预测的平滑处理" class="headerlink" title="序列预测的平滑处理"></a>序列预测的平滑处理</h3><p>包括均值化、归一化、差分、滑动窗口。</p><h3 id="装箱算法"><a href="#装箱算法" class="headerlink" title="装箱算法"></a>装箱算法</h3><p>实现了包括首次适应、多重背包、模拟退火等。</p><hr><h2 id="失败原因"><a href="#失败原因" class="headerlink" title="失败原因"></a>失败原因</h2><h3 id="华为的问题"><a href="#华为的问题" class="headerlink" title="华为的问题"></a>华为的问题</h3><ul><li>高级测试用例格式与初级不符，浪费2次机会</li><li>规定时间60s不区分语言，python直接跑超时，浪费5次机会</li></ul><h3 id="自己的问题"><a href="#自己的问题" class="headerlink" title="自己的问题"></a>自己的问题</h3><ul><li>代码的优化不好，事实上模拟退火本地应该做一个60s的测试，测最大数据量</li><li>stack过多，这种比赛，模型越简单越容易</li><li>调参大赛，前期关注在初赛刷榜，关注点有问题</li><li>python没有numpy等第三方库，实现一些算法很麻烦，效率又低</li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2018华为软件精英挑战赛初赛的思路和代码总结。&lt;/p&gt;
    
    </summary>
    
      <category term="Notes" scheme="https://ykksmile.top/categories/Notes/"/>
    
    
      <category term="Python" scheme="https://ykksmile.top/tags/Python/"/>
    
      <category term="MachineLearning" scheme="https://ykksmile.top/tags/MachineLearning/"/>
    
  </entry>
  
  <entry>
    <title>C程序在linux下的segmentation-fault（core-dumped）</title>
    <link href="https://ykksmile.top/posts/38716/"/>
    <id>https://ykksmile.top/posts/38716/</id>
    <published>2018-04-16T12:46:32.000Z</published>
    <updated>2018-06-04T12:48:20.282Z</updated>
    
    <content type="html"><![CDATA[<p>调试程序过程中出现core dumped，各种原因项目无法导入eclipse，只能使用gbd进行调试。</p><a id="more"></a><hr><h3 id="Segmentation-fault-core-dumped-原因"><a href="#Segmentation-fault-core-dumped-原因" class="headerlink" title="Segmentation fault (core dumped)原因"></a>Segmentation fault (core dumped)原因</h3><p>Segmentation fault (core dumped)多为内存不当操作造成。空指针、野指针的读写操作，数组越界访问，破坏常量等。</p><hr><h3 id="使用gdb查看core文件"><a href="#使用gdb查看core文件" class="headerlink" title="使用gdb查看core文件"></a>使用gdb查看core文件</h3><p>设置core文件大小：</p><pre><code>ulimit -aulimit -c unlimited</code></pre><p>gdb查看core文件:</p><pre><code>gdb ./file core</code></pre><hr><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><blockquote><p>输入start使程序运行到main中第一行运行代码。next或者n为执行下一行程序，until xx执行到xx行，print或p可输出变量值，b xx用于在xx行设置断点，run或r用于执行程序至下一断点，d xx删除xx行断点。<br>我们可以先run一遍程序，这时它会提示出错行信息。然后until到出错行前5行，交替执行next和print，输出与出错行变量相关变量或指针的值。最终定位出错的根本操作在哪一行。修改之即可。</p></blockquote><hr><h3 id="出错原因"><a href="#出错原因" class="headerlink" title="出错原因"></a>出错原因</h3><p>数组越界，写C语言的过程中一定要密切关注数组越界问题。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#0  0x0000000000405ef0 in get_operator (fd=10, stateinfo=0x679c00 &lt;stateinfo&gt;)</span><br><span class="line">    at SIM_wifi_state.c:247</span><br><span class="line"></span><br><span class="line">warning: Source file is more recent than executable.</span><br><span class="line">247while(buff[i+1]!=&apos;\&quot;&apos;)</span><br><span class="line">[Current thread is 1 (Thread 0x7f784ff96700 (LWP 10051))]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;调试程序过程中出现core dumped，各种原因项目无法导入eclipse，只能使用gbd进行调试。&lt;/p&gt;
    
    </summary>
    
      <category term="Notes" scheme="https://ykksmile.top/categories/Notes/"/>
    
    
      <category term="Linux" scheme="https://ykksmile.top/tags/Linux/"/>
    
      <category term="C" scheme="https://ykksmile.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>使用pycharm来进行git版本控制</title>
    <link href="https://ykksmile.top/posts/26852/"/>
    <id>https://ykksmile.top/posts/26852/</id>
    <published>2018-04-08T08:32:04.000Z</published>
    <updated>2018-06-04T12:48:20.253Z</updated>
    
    <content type="html"><![CDATA[<p>pycharm是世界上最好的IDE。</p><a id="more"></a><hr><p>发现有人写的更详细，不需要写了：<br><a href="https://www.cnblogs.com/caseast/p/6085837.html" target="_blank" rel="noopener">我是传送门</a></p><h3 id="Pycharm-Error-“fatal-Could-not-read-from-remote-repository-”"><a href="#Pycharm-Error-“fatal-Could-not-read-from-remote-repository-”" class="headerlink" title="Pycharm Error “fatal: Could not read from remote repository.”"></a>Pycharm Error “fatal: Could not read from remote repository.”</h3><p>外国网友的解决方案：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~/.ssh</span><br><span class="line">ln -s github_key_name id_rsa</span><br><span class="line">ln -s github_key_name.pub id_rsa.pub</span><br></pre></td></tr></table></figure></p><p>没有用</p><p><code>重点在于setting中ssh方式要选择native</code></p><hr><h3 id="git中如何忽略文件"><a href="#git中如何忽略文件" class="headerlink" title="git中如何忽略文件"></a>git中如何忽略文件</h3><p>使用.gitignore <a href="https://github.com/cloisonne/gitignore" target="_blank" rel="noopener">github传送门</a></p><p>对于已经加入commit的，如何ignore</p><pre><code>git rm --cached -r .idea</code></pre><p>检查是否被忽略：</p><pre><code>git check-ignore -v .idea/</code></pre><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;pycharm是世界上最好的IDE。&lt;/p&gt;
    
    </summary>
    
      <category term="Notes" scheme="https://ykksmile.top/categories/Notes/"/>
    
    
      <category term="Git" scheme="https://ykksmile.top/tags/Git/"/>
    
      <category term="Pycharm" scheme="https://ykksmile.top/tags/Pycharm/"/>
    
  </entry>
  
  <entry>
    <title>leetcode数组思路总结</title>
    <link href="https://ykksmile.top/posts/47967/"/>
    <id>https://ykksmile.top/posts/47967/</id>
    <published>2018-03-12T08:46:29.000Z</published>
    <updated>2018-06-04T12:48:20.206Z</updated>
    
    <content type="html"><![CDATA[<p>暂时没什么前言。</p><a id="more"></a><hr><h2 id="N-sum类型题解"><a href="#N-sum类型题解" class="headerlink" title="N-sum类型题解"></a>N-sum类型题解</h2><h3 id="2-sum"><a href="#2-sum" class="headerlink" title="2-sum"></a>2-sum</h3><p>两种解法：</p><ul><li>排序，双指针首尾搜索，逐渐逼近</li><li>固定一个数，寻找(target-n)，使用了hashtable方法</li></ul><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self,nums,target)</span>:</span></span><br><span class="line">lookup = []</span><br><span class="line"><span class="keyword">for</span> i,num <span class="keyword">in</span> enumerate(nums):</span><br><span class="line"><span class="keyword">if</span> target-num <span class="keyword">in</span> lookup:</span><br><span class="line"><span class="keyword">return</span> [lookup[target-num], i]</span><br><span class="line">lookup[num] = i</span><br></pre></td></tr></table></figure><hr><p>## </p><p>### </p><hr><p>## </p><p>### </p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;暂时没什么前言。&lt;/p&gt;
    
    </summary>
    
      <category term="Codes" scheme="https://ykksmile.top/categories/Codes/"/>
    
    
      <category term="Python" scheme="https://ykksmile.top/tags/Python/"/>
    
      <category term="Leetcode" scheme="https://ykksmile.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode位运算思路总结</title>
    <link href="https://ykksmile.top/posts/24951/"/>
    <id>https://ykksmile.top/posts/24951/</id>
    <published>2018-03-12T07:07:20.000Z</published>
    <updated>2018-06-04T12:48:20.219Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode位运算题解和总结，使用Python完成，未来选择性的加入lintcode题解。</p><a id="more"></a><hr><p>Python3题解及刷题完成度详见gayhub：</p><div class="github-widget" data-repo="cloisonne/LeetCode"></div><hr><h3 id="Single-Number："><a href="#Single-Number：" class="headerlink" title="Single Number："></a>Single Number：</h3><p>对数组中的元素一一异或，相同的数异或=0。</p><p>实现异或的两种方式：<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_xor</span><span class="params">(self,a,b)</span>:</span></span><br><span class="line"><span class="keyword">return</span> a^b</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> reduce(operator.xor, A)</span><br></pre></td></tr></table></figure></p><hr><h3 id="Single-Number-Ⅱ"><a href="#Single-Number-Ⅱ" class="headerlink" title="Single Number Ⅱ"></a>Single Number Ⅱ</h3><p>其他元素出现3次，使用统计方法或者位运算。<br>位运算解法和其他元素出现4次时的解法：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># one 出现一次  two 出现两次  three 出现三次</span></span><br><span class="line">one, two = <span class="number">0</span></span><br><span class="line">one, two = (~x &amp; one) | (x &amp; ~one &amp; ~two), (~x &amp; two) | (x &amp; one)</span><br><span class="line">one, two, three = (~x &amp; one) | (x &amp; ~one &amp; ~two &amp; ~three), (~x &amp; two) | (x &amp; one), (~x &amp; three) | (x &amp; two)</span><br></pre></td></tr></table></figure><p>使用counter计算：<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">return</span> (collections.Counter(list(set(nums))*<span class="number">3</span>) - collections.Counter(nums)).keys()[<span class="number">0</span>]</span><br></pre></td></tr></table></figure></p><hr><h3 id="Single-Number-Ⅲ"><a href="#Single-Number-Ⅲ" class="headerlink" title="Single Number Ⅲ"></a>Single Number Ⅲ</h3><p>两个元素出现一次，其他元素出现两次<br>全部异或，得到xor，获得bit：</p><pre><code>bit = xor &amp; ~xor</code></pre><p>bit是两个数第一个不相同的位</p><pre><code>result[bool(i&amp;bit)] ^= i</code></pre><p>其他数异或下来都是0 ， 这两个数异或下来的bool值一个是1 一个是0，成功分到了一个数组中。</p><hr><h3 id="Reverse-Bits"><a href="#Reverse-Bits" class="headerlink" title="Reverse Bits"></a>Reverse Bits</h3><p>二进制翻转，原数右移一位，赋给result，result左移一位：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">result = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">result &lt;&lt;= <span class="number">1</span></span><br><span class="line">result |= n&amp;<span class="number">1</span> <span class="comment"># 取右边第一位</span></span><br><span class="line">n &gt;&gt;= <span class="number">1</span></span><br></pre></td></tr></table></figure><p>使用zfill（返回指定长度的字符串–右对齐）的一行解：</p><pre><code>return int(bin(n)[2:].zfill(32)[::-1], 2) # bin()开头是0b</code></pre><p>Q:<code>如果该方法被大量调用，或者用于处理超大数据（Bulk data）时有什么优化方法？</code></p><p>A:将数字分成8份，每份只能是0-15，记录0-15的翻转值，array或者map：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] reverseHex = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">0</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">14</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">13</span>, <span class="number">3</span>, <span class="number">11</span>, <span class="number">7</span>, <span class="number">15</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// you need treat n as an unsigned value</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rev = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        rev = (rev &lt;&lt; <span class="number">4</span>) + reverseHex[n &amp; <span class="number">0xF</span>];</span><br><span class="line">        n &gt;&gt;&gt;= <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h3 id="Number-of-1-Bits"><a href="#Number-of-1-Bits" class="headerlink" title="Number of 1 Bits"></a>Number of 1 Bits</h3><p>求出二进制数中1的个数</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span><span class="params">(self, n)</span>:</span></span><br><span class="line">result = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> n:</span><br><span class="line">n &amp;= n - <span class="number">1</span></span><br><span class="line">result += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p><code>n&amp;(n-1)的妙用</code>:</p><pre><code>n与n-1的区别在于,对于n,从右向左数的第一个&quot;1&quot;开始一直到右,和n-1,完全相反n&amp;(n-1)作用：将n的二进制表示中的最低位为1的改为0</code></pre><hr><h3 id="Bitwise-AND-of-Numbers-Range"><a href="#Bitwise-AND-of-Numbers-Range" class="headerlink" title="Bitwise AND of Numbers Range"></a>Bitwise AND of Numbers Range</h3><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;leetcode位运算题解和总结，使用Python完成，未来选择性的加入lintcode题解。&lt;/p&gt;
    
    </summary>
    
      <category term="Codes" scheme="https://ykksmile.top/categories/Codes/"/>
    
    
      <category term="Python" scheme="https://ykksmile.top/tags/Python/"/>
    
      <category term="Leetcode" scheme="https://ykksmile.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>面试准备阅读列表</title>
    <link href="https://ykksmile.top/posts/55073/"/>
    <id>https://ykksmile.top/posts/55073/</id>
    <published>2018-03-07T08:07:00.000Z</published>
    <updated>2018-06-18T12:58:17.569Z</updated>
    
    <content type="html"><![CDATA[<p>习惯了手写笔记，将学习过程阅读的资料记录在这篇文档里，陆续增加。</p><a id="more"></a><hr><h3 id="书目"><a href="#书目" class="headerlink" title="书目"></a>书目</h3><ol><li>《机器学习》周志华 2018.2</li><li>《python高性能编程》 2018.3</li></ol><hr><h3 id="传统机器学习"><a href="#传统机器学习" class="headerlink" title="传统机器学习"></a>传统机器学习</h3><ol><li><a href="https://blog.csdn.net/v_JULY_v/article/details/78121924" target="_blank" rel="noopener">BAT机器学习面试1000题系列 </a> 每日刷</li><li><a href="http://blog.csdn.net/zouxy09/article/details/8537620/" target="_blank" rel="noopener">从最大似然到EM算法浅解 </a> 2018.3.7</li><li><a href="https://blog.csdn.net/mingtian715/article/details/53488094" target="_blank" rel="noopener">机器学习中的PR曲线和ROC曲线  </a> 2018.3.23</li><li><a href="https://blog.csdn.net/yanyanyufei96/article/details/71195063" target="_blank" rel="noopener">VotingClassifier 模型聚合——投票</a> 2018.3.25</li><li><a href="https://www.cnblogs.com/waring/p/5890214.html" target="_blank" rel="noopener">非平衡数据机器学习</a> 2018.3.25</li><li><a href="http://www.bubuko.com/infodetail-2133893.html" target="_blank" rel="noopener">机器学习：概率校准</a> 2018.3.25</li><li><a href="https://blog.csdn.net/u010976453/article/details/78488279" target="_blank" rel="noopener">机器学习中的损失函数 （着重比较：hinge loss vs softmax loss</a> 2018.3.25</li><li><a href="https://blog.csdn.net/july_sun/article/details/53088673" target="_blank" rel="noopener">机器学习常用的分类器比较</a> 2018.3.25</li><li><a href="https://blog.csdn.net/daunxx/article/details/51881956" target="_blank" rel="noopener">线性判别分析（Linear Discriminant Analysis）</a> 2018.3.26</li><li><a href="https://blog.csdn.net/u011001084/article/details/52523897" target="_blank" rel="noopener">机器学习常用 35 大算法盘点（附思维导图） </a> 2018.3.26</li><li><a href="https://blog.csdn.net/sinat_27554409/article/details/72823984" target="_blank" rel="noopener">机器学习的分类与主要算法对比</a> 2018.3.26</li><li><a href="https://www.cnblogs.com/maybe2030/p/5678387.html" target="_blank" rel="noopener">logistic函数和softmax函数</a> 2018.3.27</li><li><a href="https://blog.csdn.net/programmer_wei/article/details/52072939" target="_blank" rel="noopener">Logistic Regression（逻辑回归）原理及公式推导</a> 2018.3.27</li><li><a href="https://blog.csdn.net/jiede1/article/details/78245597" target="_blank" rel="noopener">机器学习算法—随机森林实现（包括回归和分类） </a> 2018.4.7</li></ol><hr><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ol><li><a href="https://linux.cn/article-7480-1.html" target="_blank" rel="noopener">每个程序员都应该收藏的算法复杂度速查表</a></li><li><a href="https://blog.csdn.net/yanzi1225627/article/details/8111929" target="_blank" rel="noopener">算法设计：如何求数组中第i大 或 第i小的数</a></li></ol><hr><h3 id="feature-engineering"><a href="#feature-engineering" class="headerlink" title="feature engineering"></a>feature engineering</h3><ol><li><a href="http://www.360doc.com/content/17/0605/12/42308479_660150397.shtml" target="_blank" rel="noopener">如何用Python对数据进行差分</a> 2018.4.8</li></ol><hr><h3 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h3><ol><li><a href="http://blog.csdn.net/flyinglittlepig/article/details/71598144" target="_blank" rel="noopener">反向传播(BPTT)与循环神经网络(RNN)文本预测</a> 2018.3.21</li><li><a href="http://blog.csdn.net/flyinglittlepig/article/details/72229041" target="_blank" rel="noopener">LSTM结构理解与python实现</a> 2018.3.21</li><li><a href="https://blog.csdn.net/hongmaodaxia/article/details/41809341" target="_blank" rel="noopener">深度学习BP算法的推导（附加RNN,LSTM的推导说明）</a> 2018.3.23</li><li><a href="http://www.cnblogs.com/iamccme/archive/2013/05/14/3078418.html" target="_blank" rel="noopener">《统计学习方法》 梯度下降的两种应用场景）</a> 2018.3.23</li><li><a href="https://blog.csdn.net/u014313009/article/details/51043064" target="_blank" rel="noopener">交叉熵代价函数（作用及公式推导）</a> 2018.3.23</li><li><a href="https://blog.csdn.net/v_july_v/article/details/51812459" target="_blank" rel="noopener">CNN笔记：通俗理解卷积神经网络</a> 2018.3.23</li><li><a href="https://blog.csdn.net/login_sonata/article/details/77488383" target="_blank" rel="noopener">CNN卷积神经网络和反向传播</a> 2018.4.5</li><li><a href="https://blog.csdn.net/dongfang1984/article/details/76974087" target="_blank" rel="noopener">pooling层是如何反向传播的？ </a> 2018.4.5</li></ol><hr><h3 id="人脸识别"><a href="#人脸识别" class="headerlink" title="人脸识别"></a>人脸识别</h3><p>详见此篇博文： <a href="/posts/9363/">有遮挡的人脸识别论文阅读整理</a> 2018.5</p><hr><h3 id="kaggle、天池"><a href="#kaggle、天池" class="headerlink" title="kaggle、天池"></a>kaggle、天池</h3><ol><li><a href="https://arxiv.org/pdf/1708.05123.pdf" target="_blank" rel="noopener">Deep &amp; Cross Network for Ad Click Predictions）</a> 2018.4.4</li></ol><hr><h3 id="自然语言处理"><a href="#自然语言处理" class="headerlink" title="自然语言处理"></a>自然语言处理</h3><ol><li><a href="https://zhuanlan.zhihu.com/p/24037830" target="_blank" rel="noopener">Spark MLlib 文本特征提取（TF-IDF/Word2Vec/CountVectorizer）</a> 2018.3.25</li><li><a href="https://blog.csdn.net/mylove0414/article/details/61616617" target="_blank" rel="noopener">大白话讲解word2vec到底在做些什么</a> 2018.3.25</li><li><a href="https://www.kaggle.com/marcospinaci/talking-plots-2-adding-grammar" target="_blank" rel="noopener">kaggle自然语言处理</a> 2018.3.25</li></ol><hr><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><ol><li><a href="https://blog.csdn.net/sinat_16790541/article/details/43376741" target="_blank" rel="noopener">python 模块相互import</a> 2018.4.6</li><li><a href="https://segmentfault.com/a/1190000009398663" target="_blank" rel="noopener">简单聊聊Python中的wraps修饰器</a> 2018.4.6</li></ol><hr><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ol><li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-nohup/" target="_blank" rel="noopener">Linux 技巧：让进程在后台可靠运行的几种方法</a> 2018.4.24</li><li><a href="https://blog.csdn.net/u013983194/article/details/78546599" target="_blank" rel="noopener">ubuntu16.04搭建ss服务器 </a> 2018.4.24</li><li><a href="http://blog.51cto.com/13589319/2068374" target="_blank" rel="noopener">Ubuntu系统SS搭建配置 </a></li><li><a href="https://blog.csdn.net/yangzhiwen56/article/details/50592891" target="_blank" rel="noopener">yocto环境学习–工具链和单独编译uboot,kernel</a></li><li><a href="http://blog.chinaunix.net/uid-23069658-id-3160506.html" target="_blank" rel="noopener">洞悉linux下的Netfilter&amp;iptables：什么是Netfilter？</a></li><li><a href="http://www.cnblogs.com/Swartz/articles/3939382.html" target="_blank" rel="noopener">编译程序加不加 -lpthread 的区别</a></li></ol><hr><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><ol><li><a href="https://blog.csdn.net/moliilom/article/details/50909096" target="_blank" rel="noopener">Java语言中try-catch-finally的执行顺序</a> 2018.4.10</li></ol><hr><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><ol><li><a href="https://blog.csdn.net/wangyunpeng0319/article/details/78651998" target="_blank" rel="noopener">RPC服务和HTTP服务对比</a> 2018.3.25</li></ol><hr><h3 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h3><ol><li><a href="https://github.com/airzhangfish/blockchaincat" target="_blank" rel="noopener">基于区块链的底层实现demo-猫币 </a></li><li><a href="https://learnblockchain.cn/2017/10/27/build_blockchain_by_python/" target="_blank" rel="noopener">用Python从零开始创建区块链</a></li></ol><hr><h3 id="其他的收藏"><a href="#其他的收藏" class="headerlink" title="其他的收藏"></a>其他的收藏</h3><ol><li><a href="http://blog.csdn.net/stpeace/article/details/45767245" target="_blank" rel="noopener"> 彻底解读剪不断理还乱的\r\n和\n </a> 2018.3.22</li><li><a href="https://windows.php.net/download#php-5.6" target="_blank" rel="noopener">PHP 5.6 (5.6.36)</a></li><li><a href="https://www.cnblogs.com/Ai-heng/p/7289241.html" target="_blank" rel="noopener">Windows10系统PHP开发环境配置</a></li><li><a href="http://www.apachelounge.com/download/" target="_blank" rel="noopener">Apache 2.4 VC15 Windows Binaries and Modules</a></li><li><a href="https://www.cnblogs.com/cyrfr/p/6483529.html" target="_blank" rel="noopener">php 手动搭建环境</a></li><li><a href="https://segmentfault.com/a/1190000009871504" target="_blank" rel="noopener">如何运行一个Vue项目</a></li><li><a href="https://segmentfault.com/a/1190000012239934" target="_blank" rel="noopener">如何运行vue项目（从gethub上download的开源项目）</a></li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;习惯了手写笔记，将学习过程阅读的资料记录在这篇文档里，陆续增加。&lt;/p&gt;
    
    </summary>
    
      <category term="Notes" scheme="https://ykksmile.top/categories/Notes/"/>
    
    
      <category term="MachineLearning" scheme="https://ykksmile.top/tags/MachineLearning/"/>
    
  </entry>
  
  <entry>
    <title>google机器学习速成课程总结</title>
    <link href="https://ykksmile.top/posts/61970/"/>
    <id>https://ykksmile.top/posts/61970/</id>
    <published>2018-03-05T06:13:00.000Z</published>
    <updated>2018-06-04T12:48:20.176Z</updated>
    
    <content type="html"><![CDATA[<p>Google新出的16小时机器学习速成课程，主要针对TensorFlow，记一些重点。主题不支持MathJax，公式省略。</p><a id="more"></a><hr><h2 id="机器学习概念"><a href="#机器学习概念" class="headerlink" title="机器学习概念"></a>机器学习概念</h2><hr><h3 id="机器学习主要术语"><a href="#机器学习主要术语" class="headerlink" title="机器学习主要术语"></a>机器学习主要术语</h3><h4 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h4><p>在简单线性回归中，标签是我们要预测的事物，即 y 变量。标签可以是小麦未来的价格、图片中显示的动物品种、音频剪辑的含义或任何事物。</p><h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><p>在简单线性回归中，特征是输入变量，即 x 变量。简单的机器学习项目可能会使用单个特征，而比较复杂的机器学习项目可能会使用数百万个特征，按如下方式指定：</p><p>在垃圾邮件检测器示例中，特征可能包括：</p><ul><li>电子邮件文本中的字词</li><li>发件人的地址</li><li>发送电子邮件的时段</li><li>电子邮件中包含“一种奇怪的把戏”这样的短语。</li></ul><h4 id="样本"><a href="#样本" class="headerlink" title="样本"></a>样本</h4><p>样本是指数据的特定实例：x。（我们采用粗体 x 表示它是一个矢量。）我们将样本分为以下两类：</p><ul><li>有标签样本</li><li>无标签样本</li></ul><h4 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h4><p>模型定义了特征与标签之间的关系。例如，垃圾邮件检测模型可能会将某些特征与“垃圾邮件”紧密联系起来。我们来重点介绍一下模型生命周期的两个阶段：</p><ul><li><p>训练表示创建或学习模型。也就是说，您向模型展示有标签样本，让模型逐渐学习特征与标签之间的关系。</p></li><li><p>推断表示将训练后的模型应用于无标签样本。也就是说，您使用训练后的模型来做出有用的预测 (y’)。</p></li></ul><h4 id="回归与分类"><a href="#回归与分类" class="headerlink" title="回归与分类"></a>回归与分类</h4><ul><li><p>回归模型可预测连续值。例如，回归模型做出的预测可回答如下问题：</p></li><li><p>分类模型可预测离散值。例如，分类模型做出的预测可回答如下问题：</p></li></ul><hr><h3 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h3><p>过</p><hr><h3 id="训练与损失"><a href="#训练与损失" class="headerlink" title="训练与损失"></a>训练与损失</h3><p>损失是对糟糕预测的惩罚。也就是说，损失是一个数值，表示对于单个样本而言模型预测的准确程度。如果模型的预测完全准确，则损失为零，否则损失会较大。训练模型的目标是从所有样本中找到一组平均损失“较小”的权重和偏差。</p><ul><li><p>平方损失（又称为 L2 损失）</p></li><li><p>均方误差 (MSE)</p><p>  求出各个样本的所有平方损失之和，然后除以样本数量</p></li></ul><hr><h3 id="降低损失-Reducing-Loss"><a href="#降低损失-Reducing-Loss" class="headerlink" title="降低损失(Reducing Loss)"></a>降低损失(Reducing Loss)</h3><ul><li><p>迭代方法</p></li><li><p>梯度下降法</p></li><li><p>学习速率</p></li><li><p>优化学习速率</p></li><li><p>随机梯度下降法（SGD）</p><p>  小批量随机梯度下降法（小批量 SGD）是介于全批量迭代与 SGD 之间的折衷方案。小批量通常包含 10-1000 个随机选择的样本。小批量 SGD 可以减少 SGD 中的杂乱样本数量，但仍然比全批量更高效。</p></li></ul><hr><h3 id="使用-TensorFlow-的起始步骤"><a href="#使用-TensorFlow-的起始步骤" class="headerlink" title="使用 TensorFlow 的起始步骤"></a>使用 TensorFlow 的起始步骤</h3><table><thead><tr><th>工具包</th><th>说明</th></tr></thead><tbody><tr><td>Estimator (tf.estimator)</td><td>高级 OOP API</td></tr><tr><td>tf.layers/tf.losses/tf.metrics</td><td>用于常见模型组件的库</td></tr><tr><td>TensorFlow</td><td>低级 API</td></tr></tbody></table><p>TensorFlow 由以下两个组件组成：</p><ul><li>图协议缓冲区（Protocol Buffers）</li><li>执行（分布式）图的运行时</li></ul><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set up a linear classifier.</span></span><br><span class="line">classifier = tf.estimator.LinearClassifier()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Train the model on some example data.</span></span><br><span class="line">classifier.train(input_fn=train_input_fn, steps=<span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Use it to predict.</span></span><br><span class="line">predictions = classifier.predict(input_fn=predict_input_fn)</span><br></pre></td></tr></table></figure><p>一个例子：<br>    在 TensorFlow 中使用 LinearRegressor 类并基于单个输入特征预测各城市街区的房屋价值中位数<br>    使用均方根误差 (RMSE) 评估模型预测的准确率<br>    通过调整模型的超参数提高模型准确率</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> IPython <span class="keyword">import</span> display</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> cm</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> gridspec</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow.python.data <span class="keyword">import</span> Dataset</span><br><span class="line"></span><br><span class="line">tf.logging.set_verbosity(tf.logging.ERROR)</span><br><span class="line">pd.options.display.max_rows = <span class="number">10</span></span><br><span class="line">pd.options.display.float_format = <span class="string">'&#123;:.1f&#125;'</span>.format</span><br><span class="line"></span><br><span class="line">california_housing_dataframe = pd.read_csv(<span class="string">"https://storage.googleapis.com/ml_universities/california_housing_train.csv"</span>, sep=<span class="string">","</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机化处理</span></span><br><span class="line">california_housing_dataframe = california_housing_dataframe.reindex(</span><br><span class="line">    np.random.permutation(california_housing_dataframe.index))</span><br><span class="line">california_housing_dataframe[<span class="string">"median_house_value"</span>] /= <span class="number">1000.0</span></span><br><span class="line">california_housing_dataframe</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查数据</span></span><br><span class="line">california_housing_dataframe.describe()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Define the input feature: total_rooms.</span></span><br><span class="line">my_feature = california_housing_dataframe[[<span class="string">"total_rooms"</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Configure a numeric feature column for total_rooms.</span></span><br><span class="line">feature_columns = [tf.feature_column.numeric_column(<span class="string">"total_rooms"</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Define the label.</span></span><br><span class="line">targets = california_housing_dataframe[<span class="string">"median_house_value"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Use gradient descent as the optimizer for training the model.</span></span><br><span class="line">my_optimizer=tf.train.GradientDescentOptimizer(learning_rate=<span class="number">0.0000001</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 梯度裁剪 (gradient clipping)</span></span><br><span class="line">my_optimizer = tf.contrib.estimator.clip_gradients_by_norm(my_optimizer, <span class="number">5.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Configure the linear regression model with our feature columns and optimizer.</span></span><br><span class="line"><span class="comment"># Set a learning rate of 0.0000001 for Gradient Descent.</span></span><br><span class="line">linear_regressor = tf.estimator.LinearRegressor(</span><br><span class="line">    feature_columns=feature_columns,</span><br><span class="line">    optimizer=my_optimizer</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_input_fn</span><span class="params">(features, targets, batch_size=<span class="number">1</span>, shuffle=True, num_epochs=None)</span>:</span></span><br><span class="line">    <span class="string">"""Trains a linear regression model of one feature.</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">      features: pandas DataFrame of features</span></span><br><span class="line"><span class="string">      targets: pandas DataFrame of targets</span></span><br><span class="line"><span class="string">      batch_size: Size of batches to be passed to the model</span></span><br><span class="line"><span class="string">      shuffle: True or False. Whether to shuffle the data.</span></span><br><span class="line"><span class="string">      num_epochs: Number of epochs for which data should be repeated. None = repeat indefinitely</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">      Tuple of (features, labels) for next data batch</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment"># Convert pandas data into a dict of np arrays.</span></span><br><span class="line">    features = &#123;key:np.array(value) <span class="keyword">for</span> key,value <span class="keyword">in</span> dict(features).items()&#125;                                           </span><br><span class="line"> </span><br><span class="line">    <span class="comment"># Construct a dataset, and configure batching/repeating</span></span><br><span class="line">    ds = Dataset.from_tensor_slices((features,targets)) <span class="comment"># warning: 2GB limit</span></span><br><span class="line">    ds = ds.batch(batch_size).repeat(num_epochs)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Shuffle the data, if specified</span></span><br><span class="line">    <span class="keyword">if</span> shuffle:</span><br><span class="line">      ds = ds.shuffle(buffer_size=<span class="number">10000</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Return the next batch of data</span></span><br><span class="line">    features, labels = ds.make_one_shot_iterator().get_next()</span><br><span class="line">    <span class="keyword">return</span> features, labels</span><br><span class="line"></span><br><span class="line">_ = linear_regressor.train(</span><br><span class="line">    input_fn = <span class="keyword">lambda</span>:my_input_fn(my_feature, targets),</span><br><span class="line">    steps=<span class="number">100</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create an input function for predictions.</span></span><br><span class="line"><span class="comment"># Note: Since we're making just one prediction for each example, we don't </span></span><br><span class="line"><span class="comment"># need to repeat or shuffle the data here.</span></span><br><span class="line">prediction_input_fn =<span class="keyword">lambda</span>: my_input_fn(my_feature, targets, num_epochs=<span class="number">1</span>, shuffle=<span class="keyword">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Call predict() on the linear_regressor to make predictions.</span></span><br><span class="line">predictions = linear_regressor.predict(input_fn=prediction_input_fn)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Format predictions as a NumPy array, so we can calculate error metrics.</span></span><br><span class="line">predictions = np.array([item[<span class="string">'predictions'</span>][<span class="number">0</span>] <span class="keyword">for</span> item <span class="keyword">in</span> predictions])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print Mean Squared Error and Root Mean Squared Error.</span></span><br><span class="line">mean_squared_error = metrics.mean_squared_error(predictions, targets)</span><br><span class="line">root_mean_squared_error = math.sqrt(mean_squared_error)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Mean Squared Error (on training data): %0.3f"</span> % mean_squared_error</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Root Mean Squared Error (on training data): %0.3f"</span> % root_mean_squared_error</span><br></pre></td></tr></table></figure><p>写成一个函数：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_model</span><span class="params">(learning_rate, steps, batch_size, input_feature=<span class="string">"total_rooms"</span>)</span>:</span></span><br><span class="line">  <span class="string">"""Trains a linear regression model of one feature.</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  Args:</span></span><br><span class="line"><span class="string">    learning_rate: A `float`, the learning rate.</span></span><br><span class="line"><span class="string">    steps: A non-zero `int`, the total number of training steps. A training step</span></span><br><span class="line"><span class="string">      consists of a forward and backward pass using a single batch.</span></span><br><span class="line"><span class="string">    batch_size: A non-zero `int`, the batch size.</span></span><br><span class="line"><span class="string">    input_feature: A `string` specifying a column from `california_housing_dataframe`</span></span><br><span class="line"><span class="string">      to use as input feature.</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">  </span><br><span class="line">  periods = <span class="number">10</span></span><br><span class="line">  steps_per_period = steps / periods</span><br><span class="line"></span><br><span class="line">  my_feature = input_feature</span><br><span class="line">  my_feature_data = california_housing_dataframe[[my_feature]]</span><br><span class="line">  my_label = <span class="string">"median_house_value"</span></span><br><span class="line">  targets = california_housing_dataframe[my_label]</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Create feature columns</span></span><br><span class="line">  feature_columns = [tf.feature_column.numeric_column(my_feature)]</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># Create input functions</span></span><br><span class="line">  training_input_fn = <span class="keyword">lambda</span>:my_input_fn(my_feature_data, targets, batch_size=batch_size)</span><br><span class="line">  prediction_input_fn = <span class="keyword">lambda</span>: my_input_fn(my_feature_data, targets, num_epochs=<span class="number">1</span>, shuffle=<span class="keyword">False</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># Create a linear regressor object.</span></span><br><span class="line">  my_optimizer = tf.train.GradientDescentOptimizer(learning_rate=learning_rate)</span><br><span class="line">  my_optimizer = tf.contrib.estimator.clip_gradients_by_norm(my_optimizer, <span class="number">5.0</span>)</span><br><span class="line">  linear_regressor = tf.estimator.LinearRegressor(</span><br><span class="line">      feature_columns=feature_columns,</span><br><span class="line">      optimizer=my_optimizer</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Set up to plot the state of our model's line each period.</span></span><br><span class="line">  plt.figure(figsize=(<span class="number">15</span>, <span class="number">6</span>))</span><br><span class="line">  plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">  plt.title(<span class="string">"Learned Line by Period"</span>)</span><br><span class="line">  plt.ylabel(my_label)</span><br><span class="line">  plt.xlabel(my_feature)</span><br><span class="line">  sample = california_housing_dataframe.sample(n=<span class="number">300</span>)</span><br><span class="line">  plt.scatter(sample[my_feature], sample[my_label])</span><br><span class="line">  colors = [cm.coolwarm(x) <span class="keyword">for</span> x <span class="keyword">in</span> np.linspace(<span class="number">-1</span>, <span class="number">1</span>, periods)]</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Train the model, but do so inside a loop so that we can periodically assess</span></span><br><span class="line">  <span class="comment"># loss metrics.</span></span><br><span class="line">  <span class="keyword">print</span> <span class="string">"Training model..."</span></span><br><span class="line">  <span class="keyword">print</span> <span class="string">"RMSE (on training data):"</span></span><br><span class="line">  root_mean_squared_errors = []</span><br><span class="line">  <span class="keyword">for</span> period <span class="keyword">in</span> range (<span class="number">0</span>, periods):</span><br><span class="line">    <span class="comment"># Train the model, starting from the prior state.</span></span><br><span class="line">    linear_regressor.train(</span><br><span class="line">        input_fn=training_input_fn,</span><br><span class="line">        steps=steps_per_period</span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># Take a break and compute predictions.</span></span><br><span class="line">    predictions = linear_regressor.predict(input_fn=prediction_input_fn)</span><br><span class="line">    predictions = np.array([item[<span class="string">'predictions'</span>][<span class="number">0</span>] <span class="keyword">for</span> item <span class="keyword">in</span> predictions])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Compute loss.</span></span><br><span class="line">    root_mean_squared_error = math.sqrt(</span><br><span class="line">        metrics.mean_squared_error(predictions, targets))</span><br><span class="line">    <span class="comment"># Occasionally print the current loss.</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"  period %02d : %0.2f"</span> % (period, root_mean_squared_error)</span><br><span class="line">    <span class="comment"># Add the loss metrics from this period to our list.</span></span><br><span class="line">    root_mean_squared_errors.append(root_mean_squared_error)</span><br><span class="line">    <span class="comment"># Finally, track the weights and biases over time.</span></span><br><span class="line">    <span class="comment"># Apply some math to ensure that the data and line are plotted neatly.</span></span><br><span class="line">    y_extents = np.array([<span class="number">0</span>, sample[my_label].max()])</span><br><span class="line">    </span><br><span class="line">    weight = linear_regressor.get_variable_value(<span class="string">'linear/linear_model/%s/weights'</span> % input_feature)[<span class="number">0</span>]</span><br><span class="line">    bias = linear_regressor.get_variable_value(<span class="string">'linear/linear_model/bias_weights'</span>)</span><br><span class="line"></span><br><span class="line">    x_extents = (y_extents - bias) / weight</span><br><span class="line">    x_extents = np.maximum(np.minimum(x_extents,</span><br><span class="line">                                      sample[my_feature].max()),</span><br><span class="line">                           sample[my_feature].min())</span><br><span class="line">    y_extents = weight * x_extents + bias</span><br><span class="line">    plt.plot(x_extents, y_extents, color=colors[period]) </span><br><span class="line">  <span class="keyword">print</span> <span class="string">"Model training finished."</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Output a graph of loss metrics over periods.</span></span><br><span class="line">  plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">  plt.ylabel(<span class="string">'RMSE'</span>)</span><br><span class="line">  plt.xlabel(<span class="string">'Periods'</span>)</span><br><span class="line">  plt.title(<span class="string">"Root Mean Squared Error vs. Periods"</span>)</span><br><span class="line">  plt.tight_layout()</span><br><span class="line">  plt.plot(root_mean_squared_errors)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Output a table with calibration data.</span></span><br><span class="line">  calibration_data = pd.DataFrame()</span><br><span class="line">  calibration_data[<span class="string">"predictions"</span>] = pd.Series(predictions)</span><br><span class="line">  calibration_data[<span class="string">"targets"</span>] = pd.Series(targets)</span><br><span class="line">  display.display(calibration_data.describe())</span><br><span class="line"></span><br><span class="line">  <span class="keyword">print</span> <span class="string">"Final RMSE (on training data): %0.2f"</span> % root_mean_squared_error</span><br></pre></td></tr></table></figure><p><strong>常用超参数</strong></p><ul><li>steps：是指训练迭代的总次数。一步计算一批样本产生的损失，然后使用该值修改模型的权重一次。</li><li>batch size：是指单步的样本数量（随机选择）。例如，SGD 的批量大小为 1。</li></ul><p><strong>方便变量</strong></p><pre><code>periods：控制报告的粒度。例如，如果 periods 设为 7 且 steps 设为 70，则练习将每 10 步（或 7 次）输出一次损失值。与超参数不同，我们不希望您修改 periods 的值。请注意，修改 periods 不会更改您的模型所学习的内容。</code></pre><p><strong>合成特征和离群值</strong></p><ul><li>合成特征</li><li>识别离群值</li><li>截取离群值<br>  离群值设置为相对合理的最小值或最大值来进一步改进模型拟合情况。</li></ul><hr><h3 id="过拟合和泛化"><a href="#过拟合和泛化" class="headerlink" title="过拟合和泛化"></a>过拟合和泛化</h3><p>以下三项基本假设阐明了泛化：</p><ul><li>我们从分布中随机抽取独立同分布 (i.i.d) 的样本。换言之，样本之间不会互相影响。（另一种解释：i.i.d. 是表示变量随机性的一种方式）。</li><li>分布是平稳的；即分布在数据集内不会发生变化。</li><li>我们从同一分布的数据划分中抽取样本。</li></ul><hr><h3 id="拆分数据"><a href="#拆分数据" class="headerlink" title="拆分数据"></a>拆分数据</h3><ul><li>训练集 - 用于训练模型的子集。</li><li>测试集 - 用于测试训练后模型的子集。</li></ul><hr><h3 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h3><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ul><li>映射数值</li><li>映射字符串（onehot encoding</li><li>映射分类（枚举）值</li></ul><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>避免很少使用的离散特征值</li><li>最好具有清晰明确的含义</li><li>不要将“神奇”的值与实际数据混为一谈（异常值</li><li>考虑上游不稳定性<h4 id="数据清理"><a href="#数据清理" class="headerlink" title="数据清理"></a>数据清理</h4></li></ul><ol><li>缩放特征值<ul><li>帮助梯度下降法更快速地收敛。</li><li>帮助避免“NaN 陷阱”。在这种陷阱中，模型中的一个数值变成 NaN（例如，当某个值在训练期间超出浮点精确率限制时），并且模型中的所有其他数值最终也会因数学运算而变成 NaN。</li><li>帮助模型为每个特征确定合适的权重。如果没有进行特征缩放，则模型会对范围较大的特征投入过多精力。</li></ul></li><li>处理极端离群值<ul><li>对数缩放</li><li>限制特征值</li></ul></li><li>分箱（划分范围</li><li>清查</li></ol><hr><h3 id="特征组合-Feature-Crosses"><a href="#特征组合-Feature-Crosses" class="headerlink" title="特征组合(Feature Crosses)"></a>特征组合(Feature Crosses)</h3><h4 id="对非线性规律进行编码"><a href="#对非线性规律进行编码" class="headerlink" title="对非线性规律进行编码"></a>对非线性规律进行编码</h4><p>特征组合是指通过将两个或多个输入特征相乘来对特征空间中的非线性规律进行编码的合成特征。“cross”（组合）这一术语来自 cross product（向量积）。</p><h4 id="组合独热矢量"><a href="#组合独热矢量" class="headerlink" title="组合独热矢量"></a>组合独热矢量</h4><p>对独热编码进行特征组合，则会得到可解读为逻辑连接的二元特征</p><p>线性学习器可以很好地扩展到大量数据。对大规模数据集使用特征组合是学习高度复杂模型的一种有效策略。</p><hr><h3 id="简化正则化-Regularization-for-Simplicity-：L₂-正则化"><a href="#简化正则化-Regularization-for-Simplicity-：L₂-正则化" class="headerlink" title="简化正则化 (Regularization for Simplicity)：L₂ 正则化"></a>简化正则化 (Regularization for Simplicity)：L₂ 正则化</h3><p>通过降低复杂模型的复杂度来防止过拟合，这种原则称为正则化。<br>以最小化损失和复杂度为目标，这称为<code>结构风险最小化</code>.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Google新出的16小时机器学习速成课程，主要针对TensorFlow，记一些重点。主题不支持MathJax，公式省略。&lt;/p&gt;
    
    </summary>
    
      <category term="Notes" scheme="https://ykksmile.top/categories/Notes/"/>
    
    
      <category term="Python" scheme="https://ykksmile.top/tags/Python/"/>
    
      <category term="MachineLearning" scheme="https://ykksmile.top/tags/MachineLearning/"/>
    
      <category term="TensorFlow" scheme="https://ykksmile.top/tags/TensorFlow/"/>
    
  </entry>
  
  <entry>
    <title>关于Python元类metaclass和在ORM中的应用</title>
    <link href="https://ykksmile.top/posts/29034/"/>
    <id>https://ykksmile.top/posts/29034/</id>
    <published>2018-01-24T11:02:34.000Z</published>
    <updated>2018-06-04T12:48:20.154Z</updated>
    
    <content type="html"><![CDATA[<p>元类其实并不复杂，即生成类的一个类，type可以动态创建类，同时，可以使用更为强大的metaclass。<br>ORM是这种模式的应用场景，即Object Relational Mapping。此外本文还介绍了协程coroutine和logging模块。</p><a id="more"></a><hr><h2 id="type和metaclass生成类"><a href="#type和metaclass生成类" class="headerlink" title="type和metaclass生成类"></a>type和metaclass生成类</h2><h3 id="type生成类"><a href="#type生成类" class="headerlink" title="type生成类"></a>type生成类</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">(self, name=<span class="string">'world'</span>)</span>:</span> <span class="comment"># 先定义函数</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'Hello, %s.'</span> % name)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Hello = type(<span class="string">'Hello'</span>, (object,), dict(hello=fn)) <span class="comment"># 创建Hello class</span></span><br></pre></td></tr></table></figure><h3 id="metaclass生成类"><a href="#metaclass生成类" class="headerlink" title="metaclass生成类"></a>metaclass生成类</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListMetaclass</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, bases, attrs)</span>:</span></span><br><span class="line">        attrs[<span class="string">'add'</span>] = <span class="keyword">lambda</span> self, value: self.append(value)</span><br><span class="line">        <span class="keyword">return</span> type.__new__(cls, name, bases, attrs)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyList</span><span class="params">(list, metaclass=ListMetaclass)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><hr><h2 id="ORM实例"><a href="#ORM实例" class="headerlink" title="ORM实例"></a>ORM实例</h2><h3 id="廖雪峰简单ORM"><a href="#廖雪峰简单ORM" class="headerlink" title="廖雪峰简单ORM"></a>廖雪峰简单ORM</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用metaclass写一个ORM的demo</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Field</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, column_type)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.column_type = column_type</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回对象的字符串表达式</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;%s:%s&gt;'</span> % (self.__class__.name, self.name)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringField</span><span class="params">(Field)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        super(StringField, self).__init__(name,<span class="string">'varchar(100)'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntagerField</span><span class="params">(Field)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        super(IntagerField, self).__init__(name, <span class="string">'bigint'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelMetaclass</span><span class="params">(type)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, bases, attrs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> name == <span class="string">'Model'</span>:</span><br><span class="line">            <span class="keyword">return</span> type.__new__(cls,name,bases,attrs)</span><br><span class="line">        print(<span class="string">'Found model: %s'</span> % name)</span><br><span class="line">        mappings = dict()</span><br><span class="line">        <span class="keyword">for</span> k,v <span class="keyword">in</span> attrs.items():</span><br><span class="line">            <span class="keyword">if</span> isinstance(v, Field):</span><br><span class="line">                print(<span class="string">'Found mapping: %s ==&gt; %s'</span> % (k,v))</span><br><span class="line">                mappings[k] = v</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> mappings.keys():</span><br><span class="line">            attrs.pop()</span><br><span class="line">        attrs[<span class="string">'__mappings__'</span>] = mappings</span><br><span class="line">        attrs[<span class="string">'__table__'</span>] = name</span><br><span class="line">        <span class="keyword">return</span> type.__new__(cls, name, bases, attrs)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span><span class="params">(dict, metaclass=ModelMetaclass)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, **kw)</span>:</span></span><br><span class="line">        super(Model, self).__init__(**kw)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> self[key]</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(<span class="string">r"'Model' object has no attribute '%s'"</span> % key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        self[key] = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save</span><span class="params">(self)</span>:</span></span><br><span class="line">        fields = []</span><br><span class="line">        params = []</span><br><span class="line">        args = []</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> self.__mappings__.items():</span><br><span class="line">            fields.append(v.name)</span><br><span class="line">            params.append(<span class="string">'?'</span>)</span><br><span class="line">            args.append(getattr(self, k, <span class="keyword">None</span>))</span><br><span class="line">        sql = <span class="string">'insert into %s (%s) values (%s)'</span> % (self.__table__, <span class="string">','</span>.join(fields), <span class="string">','</span>.join(params))</span><br><span class="line">        print(<span class="string">'SQL: %s'</span> % sql)</span><br><span class="line">        print(<span class="string">'ARGS: %s'</span> % str(args))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用方法</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(Model)</span>:</span></span><br><span class="line">    id = IntagerField(<span class="string">'id'</span>)</span><br><span class="line">    name = StringField(<span class="string">'username'</span>)</span><br><span class="line">    email = StringField(<span class="string">'email'</span>)</span><br><span class="line">    password = StringField(<span class="string">'password'</span>)</span><br><span class="line"></span><br><span class="line">u = User(id = <span class="number">12345</span>, name = <span class="string">'Li'</span>, email = <span class="string">'123'</span>, password = <span class="string">'22'</span>)</span><br><span class="line"></span><br><span class="line">u.save()</span><br></pre></td></tr></table></figure><h3 id="更复杂的一个ORM"><a href="#更复杂的一个ORM" class="headerlink" title="更复杂的一个ORM"></a>更复杂的一个ORM</h3><p>来自<a href="http://www.songluyi.com/python-%e7%bc%96%e5%86%99orm%e6%97%b6%e7%9a%84%e9%87%8d%e9%9a%be%e7%82%b9%e6%8e%8c%e6%8f%a1/" target="_blank" rel="noopener">编写orm时的重难点掌握</a></p><p>代码比较复杂：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.basicConfig(level=logging.INFO)</span><br><span class="line"><span class="comment"># 一次使用异步 处处使用异步</span></span><br><span class="line"><span class="keyword">import</span> aiomysql</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(sql,args=<span class="params">()</span>)</span>:</span></span><br><span class="line">    logging.info(<span class="string">'SQL:%s'</span> %sql)</span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_pool</span><span class="params">(loop, **kw)</span>:</span></span><br><span class="line">    logging.info(<span class="string">' start creating database connection pool'</span>)</span><br><span class="line">    <span class="keyword">global</span> __pool</span><br><span class="line">    <span class="comment"># 理解这里的yield from 是很重要的</span></span><br><span class="line">    __pool=<span class="keyword">yield</span> <span class="keyword">from</span> aiomysql.create_pool(</span><br><span class="line">        host=kw.get(<span class="string">'host'</span>,<span class="string">'localhost'</span>),</span><br><span class="line">        port=kw.get(<span class="string">'port'</span>,<span class="number">3306</span>),</span><br><span class="line">        user=kw[<span class="string">'user'</span>],</span><br><span class="line">        password=kw[<span class="string">'password'</span>],</span><br><span class="line">        db=kw[<span class="string">'db'</span>],</span><br><span class="line">        charset=kw.get(<span class="string">'charset'</span>,<span class="string">'utf8'</span>),</span><br><span class="line">        autocommit=kw.get(<span class="string">'autocommit'</span>,<span class="keyword">True</span>),</span><br><span class="line">        maxsize=kw.get(<span class="string">'maxsize'</span>,<span class="number">10</span>),</span><br><span class="line">        <span class="comment"># 目前不清楚这个minsize是什么鬼</span></span><br><span class="line">        minsize=kw.get(<span class="string">'minsize'</span>,<span class="number">1</span>),</span><br><span class="line">        loop=loop</span><br><span class="line">        )</span><br><span class="line"> </span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">destroy_pool</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> __pool</span><br><span class="line">    <span class="keyword">if</span> __pool <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> :</span><br><span class="line">        __pool.close()</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> __pool.wait_closed()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 我很好奇为啥不用commit 事务不用提交么</span></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select</span><span class="params">(sql, args, size=None)</span>:</span></span><br><span class="line">    log(sql,args)</span><br><span class="line">    <span class="keyword">global</span> __pool</span><br><span class="line">    <span class="comment"># 666 建立游标</span></span><br><span class="line">    <span class="comment"># -*- yield from 将会调用一个子协程，并直接返回调用的结果</span></span><br><span class="line">    <span class="comment"># yield from从连接池中返回一个连接</span></span><br><span class="line">    <span class="keyword">with</span> (<span class="keyword">yield</span> <span class="keyword">from</span> __pool)<span class="keyword">as</span> conn:</span><br><span class="line">        cur = <span class="keyword">yield</span> <span class="keyword">from</span> conn.cursor(aiomysql.DictCursor)</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> cur.execute(sql.replace(<span class="string">'?'</span>, <span class="string">'%s'</span>), args)</span><br><span class="line">        <span class="keyword">if</span> size:</span><br><span class="line">            rs = <span class="keyword">yield</span> <span class="keyword">from</span> cur.fetchmany(size)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            rs = <span class="keyword">yield</span> <span class="keyword">from</span> cur.fetchall()</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> cur.close()</span><br><span class="line">        logging.info(<span class="string">'rows have returned %s'</span> %len(rs))</span><br><span class="line">    <span class="keyword">return</span> rs</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 封装INSERT, UPDATE, DELETE</span></span><br><span class="line"><span class="comment"># 语句操作参数一样，所以定义一个通用的执行函数</span></span><br><span class="line"><span class="comment"># 返回操作影响的行号</span></span><br><span class="line"><span class="comment"># 我想说的是 知道影响行号有个叼用</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">execute</span><span class="params">(sql,args, autocommit=True)</span>:</span></span><br><span class="line">    log(sql)</span><br><span class="line">    <span class="keyword">global</span> __pool</span><br><span class="line">    <span class="keyword">with</span> (<span class="keyword">yield</span> <span class="keyword">from</span> __pool) <span class="keyword">as</span> conn:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 因为execute类型sql操作返回结果只有行号，不需要dict</span></span><br><span class="line">            cur = <span class="keyword">yield</span> <span class="keyword">from</span> conn.cursor()</span><br><span class="line">            <span class="comment"># 顺便说一下 后面的args 别掉了 掉了是无论如何都插入不了数据的</span></span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">from</span> cur.execute(sql.replace(<span class="string">'?'</span>, <span class="string">'%s'</span>), args)</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">from</span> conn.commit()</span><br><span class="line">            affected_line=cur.rowcount</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">from</span> cur.close()</span><br><span class="line">            print(<span class="string">'execute : '</span>, affected_line)</span><br><span class="line">        <span class="keyword">except</span> BaseException <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line">        <span class="keyword">return</span> affected_line</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 这个函数主要是把查询字段计数 替换成sql识别的?</span></span><br><span class="line"><span class="comment"># 比如说：insert into  `User` (`password`, `email`, `name`, `id`) values (?,?,?,?)  看到了么 后面这四个问号</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_args_string</span><span class="params">(num)</span>:</span></span><br><span class="line">    lol=[]</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> range(num):</span><br><span class="line">        lol.append(<span class="string">'?'</span>)</span><br><span class="line">    <span class="keyword">return</span> (<span class="string">','</span>.join(lol))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 定义Field类，负责保存(数据库)表的字段名和字段类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Field</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># 表的字段包含名字、类型、是否为表的主键和默认值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, column_type, primary__key, default)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.column_type=column_type</span><br><span class="line">        self.primary_key=primary__key</span><br><span class="line">        self.default=default</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 返回 表名字 字段名 和字段类型</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&amp;lt;%s , %s , %s&amp;gt;"</span> %(self.__class__.__name__, self.name, self.column_type)</span><br><span class="line"><span class="comment"># 定义数据库中五个存储类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringField</span><span class="params">(Field)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name=None, primary_key=False, default=None, ddl=<span class="string">'varchar(100)'</span>)</span>:</span></span><br><span class="line">        super().__init__(name,ddl,primary_key,default)</span><br><span class="line"><span class="comment"># 布尔类型不可以作为主键</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BooleanField</span><span class="params">(Field)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name=None, default=None)</span>:</span></span><br><span class="line">        super().__init__(name,<span class="string">'Boolean'</span>,<span class="keyword">False</span>, default)</span><br><span class="line"><span class="comment"># 不知道这个column type是否可以自己定义 先自己定义看一下</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntegerField</span><span class="params">(Field)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name=None, primary_key=False, default=<span class="number">0</span>)</span>:</span></span><br><span class="line">        super().__init__(name, <span class="string">'int'</span>, primary_key, default)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FloatField</span><span class="params">(Field)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name=None, primary_key=False,default=<span class="number">0.0</span>)</span>:</span></span><br><span class="line">        super().__init__(name, <span class="string">'float'</span>, primary_key, default)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextField</span><span class="params">(Field)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name=None, default=None)</span>:</span></span><br><span class="line">        super().__init__(name,<span class="string">'text'</span>,<span class="keyword">False</span>, default)</span><br><span class="line"><span class="comment"># class Model(dict,metaclass=ModelMetaclass):</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># -*-定义Model的元类</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 所有的元类都继承自type</span></span><br><span class="line"><span class="comment"># ModelMetaclass元类定义了所有Model基类(继承ModelMetaclass)的子类实现的操作</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># -*-ModelMetaclass的工作主要是为一个数据库表映射成一个封装的类做准备：</span></span><br><span class="line"><span class="comment"># ***读取具体子类(user)的映射信息</span></span><br><span class="line"><span class="comment"># 创造类的时候，排除对Model类的修改</span></span><br><span class="line"><span class="comment"># 在当前类中查找所有的类属性(attrs)，如果找到Field属性，就将其保存到__mappings__的dict中，同时从类属性中删除Field(防止实例属性遮住类的同名属性)</span></span><br><span class="line"><span class="comment"># 将数据库表名保存到__table__中</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 完成这些工作就可以在Model中定义各种数据库的操作方法</span></span><br><span class="line"><span class="comment"># metaclass是类的模板，所以必须从`type`类型派生：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelMetaclass</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="comment"># __new__控制__init__的执行，所以在其执行之前</span></span><br><span class="line">    <span class="comment"># cls:代表要__init__的类，此参数在实例化时由Python解释器自动提供(例如下文的User和Model)</span></span><br><span class="line">    <span class="comment"># bases：代表继承父类的集合</span></span><br><span class="line">    <span class="comment"># attrs：类的方法集合</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, bases, attrs)</span>:</span></span><br><span class="line">        <span class="comment"># 排除model 是因为要排除对model类的修改</span></span><br><span class="line">        <span class="keyword">if</span> name==<span class="string">'Model'</span>:</span><br><span class="line">            <span class="keyword">return</span> type.__new__(cls, name, bases, attrs)</span><br><span class="line">        <span class="comment"># 获取table名称 为啥获取table名称 至于在哪里我也是不明白握草</span></span><br><span class="line">        table_name=attrs.get(<span class="string">'__table__'</span>, <span class="keyword">None</span>) <span class="keyword">or</span> name</span><br><span class="line">        logging.info(<span class="string">'found table: %s (table: %s) '</span> %(name,table_name ))</span><br><span class="line">        <span class="comment"># 获取Field所有主键名和Field</span></span><br><span class="line">        mappings=dict()</span><br><span class="line">        fields=[]</span><br><span class="line">        primaryKey=<span class="keyword">None</span></span><br><span class="line">        <span class="comment"># 这个k是表示字段名</span></span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> attrs.items():</span><br><span class="line">            <span class="keyword">if</span> isinstance(v, Field):</span><br><span class="line">                logging.info(<span class="string">'Found mapping %s===&amp;gt;%s'</span> %(k, v))</span><br><span class="line">            <span class="comment"># 注意mapping的用法</span></span><br><span class="line">                mappings[k] = v</span><br><span class="line">                <span class="keyword">if</span> v.primary_key:</span><br><span class="line">                    logging.info(<span class="string">'fond primary key hahaha %s'</span>%k)</span><br><span class="line">                    <span class="comment"># 这里很有意思 当第一次主键存在primaryKey被赋值 后来如果再出现主键的话就会引发错误</span></span><br><span class="line">                    <span class="keyword">if</span> primaryKey:</span><br><span class="line">                        <span class="keyword">raise</span> RuntimeError(<span class="string">'Duplicated key for field'</span>)</span><br><span class="line">                    primaryKey=k</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    fields.append(k)</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> primaryKey:</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">'Primary key not found!'</span>)</span><br><span class="line">        <span class="comment"># w下面位字段从类属性中删除Field 属性</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> mappings.keys():</span><br><span class="line">            attrs.pop(k)</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 保存除主键外的属性为''列表形式</span></span><br><span class="line">        <span class="comment"># 这一句的lambda表达式没懂</span></span><br><span class="line">        escaped_fields=list(map(<span class="keyword">lambda</span> f:<span class="string">'`%s`'</span> %f, fields))</span><br><span class="line">        <span class="comment"># 保存属性和列的映射关系</span></span><br><span class="line">        attrs[<span class="string">'__mappings__'</span>]=mappings</span><br><span class="line">        <span class="comment"># 保存表名</span></span><br><span class="line">        attrs[<span class="string">'__table__'</span>]=table_name</span><br><span class="line">        <span class="comment"># 保存主键名称</span></span><br><span class="line">        attrs[<span class="string">'__primary_key__'</span>]=primaryKey</span><br><span class="line">        <span class="comment"># 保存主键外的属性名</span></span><br><span class="line">        attrs[<span class="string">'__fields__'</span>]=fields</span><br><span class="line">        <span class="comment"># 构造默认的增删改查 语句</span></span><br><span class="line">        attrs[<span class="string">'__select__'</span>]=<span class="string">'select `%s`, %s from `%s` '</span>%(primaryKey,<span class="string">', '</span>.join(escaped_fields), table_name)</span><br><span class="line">        attrs[<span class="string">'__insert__'</span>] = <span class="string">'insert into  `%s` (%s, `%s`) values (%s) '</span> %(table_name, <span class="string">', '</span>.join(escaped_fields), primaryKey, create_args_string(len(escaped_fields)+<span class="number">1</span>))</span><br><span class="line">        attrs[<span class="string">'__update__'</span>]=<span class="string">'update `%s` set %s where `%s` = ?'</span> %(table_name, <span class="string">', '</span>.join(map(<span class="keyword">lambda</span> f:<span class="string">'`%s`=?'</span> % (mappings.get(f).name <span class="keyword">or</span> f), fields)), primaryKey)</span><br><span class="line">        attrs[<span class="string">'__delete__'</span>]=<span class="string">'delete `%s` where `%s`=?'</span> %(table_name, primaryKey)</span><br><span class="line">        <span class="keyword">return</span> type.__new__(cls, name, bases, attrs)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 定义ORM所有映射的基类：Model</span></span><br><span class="line"><span class="comment"># Model类的任意子类可以映射一个数据库表</span></span><br><span class="line"><span class="comment"># Model类可以看作是对所有数据库表操作的基本定义的映射</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 基于字典查询形式</span></span><br><span class="line"><span class="comment"># Model从dict继承，拥有字典的所有功能，同时实现特殊方法__getattr__和__setattr__，能够实现属性操作</span></span><br><span class="line"><span class="comment"># 实现数据库操作的所有方法，定义为class方法，所有继承自Model都具有数据库操作方法</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span><span class="params">(dict,metaclass=ModelMetaclass)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, **kw)</span>:</span></span><br><span class="line">        super(Model,self).__init__(**kw)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> self[key]</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(<span class="string">"'Model' object have no attribution: %s"</span>% key)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        self[key] =value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getValue</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="comment"># 这个是默认内置函数实现的</span></span><br><span class="line">        <span class="keyword">return</span> getattr(self, key, <span class="keyword">None</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getValueOrDefault</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        value=getattr(self, key , <span class="keyword">None</span>)</span><br><span class="line">        <span class="keyword">if</span> value <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            field = self.__mappings__[key]</span><br><span class="line">            <span class="keyword">if</span> field.default <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">                value = field.default() <span class="keyword">if</span> callable(field.default) <span class="keyword">else</span> field.default</span><br><span class="line">                logging.info(<span class="string">'using default value for %s : %s '</span> % (key, str(value)))</span><br><span class="line">                setattr(self, key, value)</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line"> </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="comment"># 类方法有类变量cls传入，从而可以用cls做一些相关的处理。并且有子类继承时，调用该类方法时，传入的类变量cls是子类，而非父类。</span></span><br><span class="line"><span class="meta">    @asyncio.coroutine</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_all</span><span class="params">(cls, where=None, args=None, **kw)</span>:</span></span><br><span class="line">        sql = [cls.__select__]</span><br><span class="line">        <span class="keyword">if</span> where:</span><br><span class="line">            sql.append(<span class="string">'where'</span>)</span><br><span class="line">            sql.append(where)</span><br><span class="line">        <span class="keyword">if</span> args <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            args = []</span><br><span class="line"> </span><br><span class="line">        orderBy = kw.get(<span class="string">'orderBy'</span>, <span class="keyword">None</span>)</span><br><span class="line">        <span class="keyword">if</span> orderBy:</span><br><span class="line">            sql.append(<span class="string">'order by'</span>)</span><br><span class="line">            sql.append(orderBy)</span><br><span class="line">        <span class="comment"># dict 提供get方法 指定放不存在时候返回后学的东西 比如a.get('Fuck',None)</span></span><br><span class="line">        limit = kw.get(<span class="string">'limit'</span>, <span class="keyword">None</span>)</span><br><span class="line">        <span class="keyword">if</span> limit <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            sql.append(<span class="string">'limit'</span>)</span><br><span class="line">            <span class="keyword">if</span> isinstance(limit, int):</span><br><span class="line">                sql.append(<span class="string">'?'</span>)</span><br><span class="line">                args.append(limit)</span><br><span class="line">            <span class="keyword">elif</span> isinstance(limit, tuple) <span class="keyword">and</span> len(limit) ==<span class="number">2</span>:</span><br><span class="line">                sql.append(<span class="string">'?,?'</span>)</span><br><span class="line">                args.extend(limit)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">raise</span> ValueError(<span class="string">'Invalid limit value : %s '</span>%str(limit))</span><br><span class="line"> </span><br><span class="line">        rs = <span class="keyword">yield</span> <span class="keyword">from</span> select(<span class="string">' '</span>.join(sql),args)</span><br><span class="line">        <span class="keyword">return</span> [cls(**r) <span class="keyword">for</span> r <span class="keyword">in</span> rs]</span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line"><span class="meta">    @asyncio.coroutine</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findNumber</span><span class="params">(cls, selectField, where=None, args=None)</span>:</span></span><br><span class="line">        <span class="string">'''find number by select and where.'''</span></span><br><span class="line">        sql = [<span class="string">'select %s __num__ from `%s`'</span> %(selectField, cls.__table__)]</span><br><span class="line">        <span class="keyword">if</span> where:</span><br><span class="line">            sql.append(<span class="string">'where'</span>)</span><br><span class="line">            sql.append(where)</span><br><span class="line">        rs = <span class="keyword">yield</span> <span class="keyword">from</span> select(<span class="string">' '</span>.join(sql), args, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> len(rs) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">return</span> rs[<span class="number">0</span>][<span class="string">'__num__'</span>]</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 这个黑魔法我还在研究呢~</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line"><span class="meta">    @asyncio.coroutine</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(cls, primarykey)</span>:</span></span><br><span class="line">        <span class="string">'''find object by primary key'''</span></span><br><span class="line">        rs = <span class="keyword">yield</span> <span class="keyword">from</span> select(<span class="string">'%s where `%s`=?'</span> %(cls.__select__, cls.__primary_key__), [primarykey], <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> len(rs) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">return</span> cls(**rs[<span class="number">0</span>])</span><br><span class="line"> </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line"><span class="meta">    @asyncio.coroutine</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findAll</span><span class="params">(cls, **kw)</span>:</span></span><br><span class="line">        rs = []</span><br><span class="line">        <span class="keyword">if</span> len(kw) == <span class="number">0</span>:</span><br><span class="line">            rs = <span class="keyword">yield</span> <span class="keyword">from</span> select(cls.__select__, <span class="keyword">None</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            args=[]</span><br><span class="line">            values=[]</span><br><span class="line">            <span class="keyword">for</span> k, v <span class="keyword">in</span> kw.items():</span><br><span class="line">                args.append(<span class="string">'%s=?'</span> % k )</span><br><span class="line">                values.append(v)</span><br><span class="line">            rs = <span class="keyword">yield</span> <span class="keyword">from</span> select(<span class="string">'%s where %s '</span> % (cls.__select__,  <span class="string">' and '</span>.join(args)), values)</span><br><span class="line">        <span class="keyword">return</span> rs</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @asyncio.coroutine</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save</span><span class="params">(self)</span>:</span></span><br><span class="line">        args = list(map(self.getValueOrDefault, self.__fields__))</span><br><span class="line">        print(<span class="string">'save:%s'</span> % args)</span><br><span class="line">        args.append(self.getValueOrDefault(self.__primary_key__))</span><br><span class="line">        rows = <span class="keyword">yield</span> <span class="keyword">from</span> execute(self.__insert__, args)</span><br><span class="line">        <span class="keyword">if</span> rows != <span class="number">1</span>:</span><br><span class="line">            print(self.__insert__)</span><br><span class="line">            logging.warning(<span class="string">'failed to insert record: affected rows: %s'</span> %rows)</span><br><span class="line"> </span><br><span class="line"><span class="meta">    @asyncio.coroutine</span></span><br><span class="line">    <span class="comment"># 显示方言错误是什么鬼。。。</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self)</span>:</span></span><br><span class="line">        args = list(map(self.getValue, self.__fields__))</span><br><span class="line">        args.append(self.getValue(self.__primary_key__))</span><br><span class="line">        rows = <span class="keyword">yield</span> <span class="keyword">from</span> execute(self.__update__, args)</span><br><span class="line">        <span class="keyword">if</span> rows != <span class="number">1</span>:</span><br><span class="line">            logging.warning(<span class="string">'failed to update record: affected rows: %s'</span>%rows)</span><br><span class="line"> </span><br><span class="line"><span class="meta">    @asyncio.coroutine</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self)</span>:</span></span><br><span class="line">        args = [self.getValue(self.__primary_key__)]</span><br><span class="line">        rows = <span class="keyword">yield</span> <span class="keyword">from</span> execute(self.__updata__, args)</span><br><span class="line">        <span class="keyword">if</span> rows != <span class="number">1</span>:</span><br><span class="line">            logging.warning(<span class="string">'failed to remove by primary key: affected rows: %s'</span> %rows)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(Model)</span>:</span></span><br><span class="line">        id = IntegerField(<span class="string">'id'</span>,primary_key=<span class="keyword">True</span>)</span><br><span class="line">        name = StringField(<span class="string">'username'</span>)</span><br><span class="line">        email = StringField(<span class="string">'email'</span>)</span><br><span class="line">        password = StringField(<span class="string">'password'</span>)</span><br><span class="line">    <span class="comment">#创建异步事件的句柄</span></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line"> </span><br><span class="line">    <span class="comment">#创建实例</span></span><br><span class="line"><span class="meta">    @asyncio.coroutine</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> create_pool(loop=loop,host=<span class="string">'localhost'</span>, port=<span class="number">3308</span>, user=<span class="string">'sly'</span>, password=<span class="string">'070801382'</span>, db=<span class="string">'test'</span>)</span><br><span class="line">        user = User(id=<span class="number">8</span>, name=<span class="string">'sly'</span>, email=<span class="string">'slysly759@gmail.com'</span>, password=<span class="string">'fuckblog'</span>)</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> user.save()</span><br><span class="line">        r = <span class="keyword">yield</span> <span class="keyword">from</span> User.find(<span class="string">'11'</span>)</span><br><span class="line">        print(r)</span><br><span class="line">        r = <span class="keyword">yield</span> <span class="keyword">from</span> User.findAll()</span><br><span class="line">        print(<span class="number">1</span>, r)</span><br><span class="line">        r = <span class="keyword">yield</span> <span class="keyword">from</span> User.findAll(id=<span class="string">'12'</span>)</span><br><span class="line">        print(<span class="number">2</span>, r)</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> destroy_pool()</span><br><span class="line"> </span><br><span class="line">    loop.run_until_complete(test())</span><br><span class="line">    loop.close()</span><br><span class="line">    <span class="keyword">if</span> loop.is_closed():</span><br><span class="line">        sys.exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p><hr><h2 id="知识点学习"><a href="#知识点学习" class="headerlink" title="知识点学习"></a>知识点学习</h2><h3 id="asyncio异步IO库"><a href="#asyncio异步IO库" class="headerlink" title="asyncio异步IO库"></a>asyncio异步IO库</h3><p>廖雪峰中的asyncio异步获取网页例子：</p><p>注意异步操作需要在<code>coroutine</code>中通过<code>yield from</code>完成</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wget</span><span class="params">(host)</span>:</span></span><br><span class="line">    print(<span class="string">'wget %s...'</span> % host)</span><br><span class="line">    connect = asyncio.open_connection(host, <span class="number">80</span>)</span><br><span class="line">    reader, writer = <span class="keyword">yield</span> <span class="keyword">from</span> connect</span><br><span class="line">    header = <span class="string">'GET / HTTP/1.0\r\nHost: %s\r\n\r\n'</span> % host</span><br><span class="line">    writer.write(header.encode(<span class="string">'utf-8'</span>))</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> writer.drain()</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        line = <span class="keyword">yield</span> <span class="keyword">from</span> reader.readline()</span><br><span class="line">        <span class="keyword">if</span> line == <span class="string">b'\r\n'</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        print(<span class="string">'%s header &gt; %s'</span> % (host, line.decode(<span class="string">'utf-8'</span>).rstrip()))</span><br><span class="line">    <span class="comment"># Ignore the body, close the socket</span></span><br><span class="line">    writer.close()</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">tasks = [wget(host) <span class="keyword">for</span> host <span class="keyword">in</span> [<span class="string">'www.sina.com.cn'</span>, <span class="string">'www.sohu.com'</span>, <span class="string">'www.163.com'</span>]]</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure><h3 id="logging日志库"><a href="#logging日志库" class="headerlink" title="logging日志库"></a>logging日志库</h3><p>知乎上有个问题里拿来的demo:</p><p>问题是为什么pycharm的traceback还有ERROR等打印顺序会发生变化，加了sleep就不会变化了。</p><p>我猜测是pycharm有一些异步执行的步骤，具体也没有在StackOverflow上找到答案。<code>作为TODO吧</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">logging.basicConfig(level=logging.DEBUG)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'try'</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    r = <span class="number">10</span> / int(<span class="string">'a'</span>)</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'result'</span>, r)</span><br><span class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    logging.exception(e)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'exception'</span>, e)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'no error'</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'finally.'</span>)</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'END**************'</span>)</span><br></pre></td></tr></table></figure><p>logging的级别：</p><ul><li>DEBUG</li><li>INFO</li><li>WARNING</li><li>ERROR</li><li>CRITICAL</li><li>NOSET</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">logger.debug(<span class="string">'debug message'</span>)</span><br><span class="line">logger.info(<span class="string">'info message'</span>)</span><br><span class="line">logger.warn(<span class="string">'warn message'</span>)</span><br><span class="line">logger.error(<span class="string">'error message'</span>)</span><br><span class="line">logger.critical(<span class="string">'critical message'</span>)</span><br></pre></td></tr></table></figure><h3 id="yield和yield-from"><a href="#yield和yield-from" class="headerlink" title="yield和yield from"></a>yield和yield from</h3><h4 id="三个概念："><a href="#三个概念：" class="headerlink" title="三个概念："></a>三个概念：</h4><ul><li>生成器<br>  一边循环一边计算的机制，称为生成器：generator</li><li>可迭代<br>  可迭代是指一种可以在容器中逐个提取元素的能力。<br>  必须具备<code>__iter__()</code></li><li>迭代器<br>  <code>__iter__()</code><br>  <code>__next__()</code></li></ul><p>yield写斐波那契</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fab_yield</span><span class="params">(max)</span>:</span></span><br><span class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n&lt;max:</span><br><span class="line">        <span class="keyword">yield</span> b</span><br><span class="line">        <span class="comment"># print b</span></span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">f=fab_yield(<span class="number">100</span>)</span><br><span class="line">print(type(f))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> f:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure><h4 id="yield-from"><a href="#yield-from" class="headerlink" title="yield from"></a>yield from</h4><blockquote><p>总之大意是原本的yield语句只能将CPU控制权还给直接调用者，当你想要将一个generator或者coroutine里带有yield语句的逻辑重构到另一个generator（原文是subgenerator）里的时候，会非常麻烦，因为外面的generator要负责为里面的generator做消息传递；所以某人有个想法是让python把消息传递封装起来，使其对程序猿透明，于是就有了yield from。</p></blockquote><p>假设A函数中有这样一个语句</p><blockquote><p>yield from B()</p></blockquote><p>B()返回的是一个可迭代（iterable）的对象b，那么A()会返回一个 generator——照我们的命名规范，名字叫a——那么：</p><ol><li>b迭代产生的每个值都直接传递给a的调用者。</li><li>所有通过<code>send</code>方法发送到a的值都被直接传递给b. 如果发送的值是<code>None</code>，则调用b的<code>__next__()</code>方法，否则调用b的<code>send</code>方法。如果对b的方法调用产生<code>StopIteration</code>异常，a会继续执行<code>yield from</code>后面的语句，而其他异常则会传播到a中，导致a在执行<code>yield from</code>的时候抛出异常。</li><li>如果有除<code>GeneratorExit</code>以外的异常被throw到a中的话，该异常会被直接throw到b中。如果b的<code>throw</code>方法抛出<code>StopIteration</code>， a会继续执行；其他异常则会导致a也抛出异常。</li><li>如果一个<code>GeneratorExit</code>异常被throw到a中，或者a的<code>close</code>方法被调用了，并且b也有<code>close</code>方法的话，b的<code>close</code>方法也会被调用。如果b的这个方法抛出了异常，则会导致a也抛出异常。 反之，如果b成功close掉了，a也会抛出异常，但是是特定的<code>GeneratorExit</code>异常。</li><li>a中<code>yield fro</code>m表达式的求值结果是b迭代结束时抛出的<code>StopIteration</code>异常的第一个参数。</li><li>b中的<code>return &lt;expr&gt;</code>语句实际上会抛出<code>StopIteration(&lt;expr&gt;)</code> 异常，所以b中return的值会成为a中<code>yield from</code>表达式的返回值。</li></ol><h4 id="关于协程Coroutine"><a href="#关于协程Coroutine" class="headerlink" title="关于协程Coroutine"></a>关于协程Coroutine</h4><ul><li>不是线程切换，而是由程序自身控制，因此，没有线程切换的开销</li><li>不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;元类其实并不复杂，即生成类的一个类，type可以动态创建类，同时，可以使用更为强大的metaclass。&lt;br&gt;ORM是这种模式的应用场景，即Object Relational Mapping。此外本文还介绍了协程coroutine和logging模块。&lt;/p&gt;
    
    </summary>
    
      <category term="Codes" scheme="https://ykksmile.top/categories/Codes/"/>
    
    
      <category term="Python" scheme="https://ykksmile.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>SIM模块的串口通信例程</title>
    <link href="https://ykksmile.top/posts/42320/"/>
    <id>https://ykksmile.top/posts/42320/</id>
    <published>2018-01-17T09:19:06.000Z</published>
    <updated>2018-06-22T15:14:52.436Z</updated>
    
    <content type="html"><![CDATA[<p></p><h2 id="intro">前言</h2>项目里写的SIM模块串口通信例程，模块使用SIM7100，支持2G/3G/4G，交互使用串口中的AT命令实现，采用非阻塞，提高交互效率。<p></p><a id="more"></a><hr><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>详见gayhub：</p><div class="github-widget" data-repo="cloisonne/SIM7100-Serial-Communication"></div><hr><h3 id="函数分析"><a href="#函数分析" class="headerlink" title="函数分析"></a>函数分析</h3><p>得到的数据使用结构体保存，方便丢给主程序。<br>实现的功能函数如下，主要包括：</p><ol><li><p>串口的设置和打开</p></li><li><p>串口的发送和接受函数</p></li><li><p>获取模块的信号质量</p></li><li><p>获取模块的当前网络制式</p></li><li><p>获取模块的运营商</p></li><li><p>选择模块的网络模式</p></li><li><p>对模块的离线控制</p></li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> csq;   <span class="comment">// Signal Quality</span></span><br><span class="line"><span class="keyword">int</span> ber;   <span class="comment">// Bit Error Rate</span></span><br><span class="line"><span class="keyword">char</span> provider_name[<span class="number">30</span>]; <span class="comment">// Provider Name</span></span><br><span class="line"><span class="keyword">char</span> sim_mode[<span class="number">30</span>];</span><br><span class="line">&#125;StateInfo;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open_port</span><span class="params">(<span class="keyword">int</span> port)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">set_opt</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> nSpeed, <span class="keyword">int</span> nBits, <span class="keyword">char</span> nEvent, <span class="keyword">int</span> nStop)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">serial_send</span><span class="params">(<span class="keyword">int</span> file_descriptor, <span class="keyword">char</span> *buffer, <span class="keyword">size_t</span> data_len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_operator</span><span class="params">(<span class="keyword">int</span> fd,StateInfo *stateinfo)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_csq</span><span class="params">(<span class="keyword">int</span> fd,StateInfo *stateinfo)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_mod</span><span class="params">(<span class="keyword">int</span> fd,StateInfo *stateinfo)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mode_selection</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">int</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">offline_control</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">int</span> isornot)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">csq_detected</span><span class="params">(<span class="keyword">int</span> csq)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mod_detected</span><span class="params">(<span class="keyword">int</span> mod,StateInfo *stateinfo)</span></span>;</span><br></pre></td></tr></table></figure><hr><h3 id="获取信号质量为例"><a href="#获取信号质量为例" class="headerlink" title="获取信号质量为例"></a>获取信号质量为例</h3><p>主要是通过发送AT命令（非阻塞），并处理接受的数据，来和模块交互。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_csq</span><span class="params">(<span class="keyword">int</span> fd,StateInfo *stateinfo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> nread;</span><br><span class="line"><span class="keyword">char</span> buff[SIZE];</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> sbuffer[]=<span class="string">"AT+CSQ\r"</span>;</span><br><span class="line">serial_send(fd,sbuffer,<span class="keyword">sizeof</span>(sbuffer));</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!flag)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>((nread=read(fd,buff,SIZE))&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//printf("\nLen %d\n",nread);</span></span><br><span class="line">buff[nread]=<span class="string">'\0'</span>;</span><br><span class="line"><span class="comment">//printf("\n%s",buff);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strstr</span>(buff,<span class="string">"CSQ"</span>)!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">stateinfo-&gt;ber=<span class="number">0</span>;</span><br><span class="line">stateinfo-&gt;csq=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(buff[i]!=<span class="string">','</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(buff[i]&gt;=<span class="string">'0'</span>&amp;&amp;buff[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">&#123;</span><br><span class="line">stateinfo-&gt;csq=(stateinfo-&gt;csq)*<span class="number">10</span>+(buff[i]-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(buff[i]!=<span class="string">'\0'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(buff[i]&gt;=<span class="string">'0'</span>&amp;&amp;buff[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">&#123;</span><br><span class="line">stateinfo-&gt;ber=(stateinfo-&gt;ber)*<span class="number">10</span>+(buff[i]-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line">stateinfo-&gt;csq=csq_detected(stateinfo-&gt;csq);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//usleep(5000);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n%d + %d\n"</span>,stateinfo-&gt;csq,stateinfo-&gt;ber);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n--get csq&amp;ber end--\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;h2 id=&quot;intro&quot;&gt;前言&lt;/h2&gt;项目里写的SIM模块串口通信例程，模块使用SIM7100，支持2G/3G/4G，交互使用串口中的AT命令实现，采用非阻塞，提高交互效率。&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Codes" scheme="https://ykksmile.top/categories/Codes/"/>
    
    
      <category term="LTE" scheme="https://ykksmile.top/tags/LTE/"/>
    
      <category term="GSM" scheme="https://ykksmile.top/tags/GSM/"/>
    
      <category term="Linux" scheme="https://ykksmile.top/tags/Linux/"/>
    
      <category term="C" scheme="https://ykksmile.top/tags/C/"/>
    
  </entry>
  
</feed>
